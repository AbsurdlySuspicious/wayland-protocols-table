{
    "compositors": [
        {
            "id": "mutter",
            "name": "Mutter",
            "icon": "gnome",
            "supportedPercent": 39
        },
        {
            "id": "kwin",
            "name": "KWin",
            "icon": "kde",
            "supportedPercent": 44
        },
        {
            "id": "sway",
            "name": "Sway",
            "icon": "sway",
            "supportedPercent": 52
        },
        {
            "id": "cosmic",
            "name": "COSMIC",
            "icon": "cosmic",
            "supportedPercent": 44
        },
        {
            "id": "hyprland",
            "name": "Hyprland",
            "icon": "hyprland",
            "supportedPercent": 56
        },
        {
            "id": "niri",
            "name": "niri",
            "supportedPercent": 45
        },
        {
            "id": "weston",
            "name": "Weston",
            "icon": "weston",
            "supportedPercent": 17
        },
        {
            "id": "labwc",
            "name": "Labwc",
            "icon": "labwc",
            "supportedPercent": 51
        },
        {
            "id": "cage",
            "name": "Cage",
            "supportedPercent": 25
        },
        {
            "id": "wayfire",
            "name": "Wayfire",
            "icon": "wayfire",
            "supportedPercent": 44
        },
        {
            "id": "gamescope",
            "name": "GameScope",
            "icon": "Steam_Deck",
            "supportedPercent": 11
        },
        {
            "id": "jay",
            "name": "Jay",
            "supportedPercent": 57
        },
        {
            "id": "mir",
            "name": "Mir",
            "icon": "mir",
            "supportedPercent": 30
        },
        {
            "id": "treeland",
            "name": "Treeland",
            "icon": "deepin",
            "supportedPercent": 29
        },
        {
            "id": "louvre",
            "name": "Louvre",
            "icon": "louvre",
            "supportedPercent": 37
        }
    ],
    "protocols": [
        {
            "id": "wayland",
            "name": "Wayland",
            "descFull": [
                {
                    "title": "wl_display",
                    "text": "The core global object.  This is a special singleton object.  I s used for internal Wayland protocol features."
                },
                {
                    "title": "wl_registry",
                    "text": "The singleton global registry object.  The server has a number o lobal objects that are available to all clients.  These object ypically represent an actual object in the server (for example,\nan input device) or they are singleton objects that provid xtension functionality.\n\nWhen a client creates a registry object, the registry objec ill emit a global event for each global currently in th egistry.  Globals come and go as a result of device o onitor hotplugs, reconfiguration or other events, and th egistry will send out global and global_remove events t eep the client up to date with the changes.  To mark the en f the initial burst of events, the client can use th l_display.sync request immediately after callin l_display.get_registry.\n\nA client can bind to a global object by using the bin equest.  This creates a client-side handle that lets the objec mit events to the client and lets the client invoke requests o he object."
                },
                {
                    "title": "wl_callback",
                    "text": "Clients can handle the 'done' event to get notified whe he related request is done.\n\nNote, because wl_callback objects are created from multiple independen actory interfaces, the wl_callback interface is frozen at version 1."
                },
                {
                    "title": "wl_compositor",
                    "text": "A compositor.  This object is a singleton global.  Th ompositor is in charge of combining the contents of multipl urfaces into one displayable output."
                },
                {
                    "title": "wl_shm_pool",
                    "text": "The wl_shm_pool object encapsulates a piece of memory share etween the compositor and client.  Through the wl_shm_poo bject, the client can allocate shared memory wl_buffer objects.\nAll objects created through the same pool share the sam nderlying mapped memory. Reusing the mapped memory avoids th etup/teardown overhead and is useful when interactively resizin  surface or for many small buffers."
                },
                {
                    "title": "wl_shm",
                    "text": "A singleton global object that provides support for share emory.\n\nClients can create wl_shm_pool objects using the create_poo equest.\n\nOn binding the wl_shm object one or more format event re emitted to inform clients about the valid pixel format hat can be used for buffers."
                },
                {
                    "title": "wl_buffer",
                    "text": "A buffer provides the content for a wl_surface. Buffers ar reated through factory interfaces such as wl_shm, wp_linux_buffer_params\n(from the linux-dmabuf protocol extension) or similar. It has a width an  height and can be attached to a wl_surface, but the mechanism by which  lient provides and updates the contents is defined by the buffer factor nterface.\n\nColor channels are assumed to be electrical rather than optical (in othe ords, encoded with a transfer function) unless otherwise specified. I he buffer uses a format that has an alpha channel, the alpha channel i ssumed to be premultiplied into the electrical color channel values\n(after transfer function encoding) unless otherwise specified.\n\nNote, because wl_buffer objects are created from multiple independen actory interfaces, the wl_buffer interface is frozen at version 1."
                },
                {
                    "title": "wl_data_offer",
                    "text": "A wl_data_offer represents a piece of data offered for transfe y another client (the source client).  It is used by th opy-and-paste and drag-and-drop mechanisms.  The offe escribes the different mime types that the data can b onverted to and provides the mechanism for transferring th ata directly from the source client."
                },
                {
                    "title": "wl_data_source",
                    "text": "The wl_data_source object is the source side of a wl_data_offer.\nIt is created by the source client in a data transfer an rovides a way to describe the offered data and a way to respon o requests to transfer the data."
                },
                {
                    "title": "wl_data_device",
                    "text": "There is one wl_data_device per seat which can be obtaine rom the global wl_data_device_manager singleton.\n\nA wl_data_device provides access to inter-client data transfe echanisms such as copy-and-paste and drag-and-drop."
                },
                {
                    "title": "wl_data_device_manager",
                    "text": "The wl_data_device_manager is a singleton global object tha rovides access to inter-client data transfer mechanisms such a opy-and-paste and drag-and-drop.  These mechanisms are tied t  wl_seat and this interface lets a client get a wl_data_devic orresponding to a wl_seat.\n\nDepending on the version bound, the objects created from the boun l_data_device_manager object will have different requirements fo unctioning properly. See wl_data_source.set_actions,\nwl_data_offer.accept and wl_data_offer.finish for details."
                },
                {
                    "title": "wl_shell",
                    "text": "This interface is implemented by servers that provid esktop-style user interfaces.\n\nIt allows clients to associate a wl_shell_surface wit  basic surface.\n\nNote! This protocol is deprecated and not intended for production use.\nFor desktop-style user interfaces, use xdg_shell. Compositors and client hould not implement this interface."
                },
                {
                    "title": "wl_shell_surface",
                    "text": "An interface that may be implemented by a wl_surface, fo mplementations that provide a desktop-style user interface.\n\nIt provides requests to treat surfaces like toplevel, fullscree r popup windows, move, resize or maximize them, associat etadata like title and class, etc.\n\nOn the server side the object is automatically destroyed whe he related wl_surface is destroyed. On the client side,\nwl_shell_surface_destroy() must be called before destroyin he wl_surface object."
                },
                {
                    "title": "wl_surface",
                    "text": "A surface is a rectangular area that may be displayed on zer r more outputs, and shown any number of times at the compositor' iscretion. They can present wl_buffers, receive user input, an efine a local coordinate system.\n\nThe size of a surface (and relative positions on it) is describe n surface-local coordinates, which may differ from the buffe oordinates of the pixel content, in case a buffer_transfor r a buffer_scale is used.\n\nA surface without a \"role\" is fairly useless: a compositor doe ot know where, when or how to present it. The role is th urpose of a wl_surface. Examples of roles are a cursor for  ointer (as set by wl_pointer.set_cursor), a drag icon\n(wl_data_device.start_drag), a sub-surface\n(wl_subcompositor.get_subsurface), and a window as defined by  hell protocol (e.g. wl_shell.get_shell_surface).\n\nA surface can have only one role at a time. Initially  l_surface does not have a role. Once a wl_surface is given  ole, it is set permanently for the whole lifetime of th l_surface object. Giving the current role again is allowed,\nunless explicitly forbidden by the relevant interfac pecification.\n\nSurface roles are given by requests in other interfaces such a l_pointer.set_cursor. The request should explicitly mentio hat this request gives a role to a wl_surface. Often, thi equest also creates a new protocol object that represents th ole and adds additional functionality to wl_surface. When  lient wants to destroy a wl_surface, they must destroy this rol bject before the wl_surface, otherwise a defunct_role_object error i ent.\n\nDestroying the role object does not remove the role from th l_surface, but it may stop the wl_surface from \"playing the role\".\nFor instance, if a wl_subsurface object is destroyed, the wl_surfac t was created for will be unmapped and forget its position an -order. It is allowed to create a wl_subsurface for the sam l_surface again, but it is not allowed to use the wl_surface a  cursor (cursor is a different role than sub-surface, and rol witching is not allowed)."
                },
                {
                    "title": "wl_seat",
                    "text": "A seat is a group of keyboards, pointer and touch devices. Thi bject is published as a global during start up, or when such  evice is hot plugged.  A seat typically has a pointer an aintains a keyboard focus and a pointer focus."
                },
                {
                    "title": "wl_pointer",
                    "text": "The wl_pointer interface represents one or more input devices,\nsuch as mice, which control the pointer location and pointer_focu f a seat.\n\nThe wl_pointer interface generates motion, enter and leav vents for the surfaces that the pointer is located over,\nand button and axis events for button presses, button release nd scrolling."
                },
                {
                    "title": "wl_keyboard",
                    "text": "The wl_keyboard interface represents one or more keyboard ssociated with a seat.\n\nEach wl_keyboard has the following logical state:\n\n- an active surface (possibly null),\n- the keys currently logically down,\n- the active modifiers,\n- the active group.\n\nBy default, the active surface is null, the keys currently logically dow re empty, the active modifiers and the active group are 0."
                },
                {
                    "title": "wl_touch",
                    "text": "The wl_touch interface represents a touchscree ssociated with a seat.\n\nTouch interactions can consist of one or more contacts.\nFor each contact, a series of events is generated, startin ith a down event, followed by zero or more motion events,\nand ending with an up event. Events relating to the sam ontact point can be identified by the ID of the sequence."
                },
                {
                    "title": "wl_output",
                    "text": "An output describes part of the compositor geometry.  Th ompositor works in the 'compositor coordinate system' and a utput corresponds to a rectangular area in that space that i ctually visible.  This typically corresponds to a monitor tha isplays part of the compositor space.  This object is publishe s global during start up, or when a monitor is hotplugged."
                },
                {
                    "title": "wl_region",
                    "text": "A region object describes an area.\n\nRegion objects are used to describe the opaque and inpu egions of a surface."
                },
                {
                    "title": "wl_subcompositor",
                    "text": "The global interface exposing sub-surface compositing capabilities.\nA wl_surface, that has sub-surfaces associated, is called th arent surface. Sub-surfaces can be arbitrarily nested and creat  tree of sub-surfaces.\n\nThe root surface in a tree of sub-surfaces is the mai urface. The main surface cannot be a sub-surface, becaus ub-surfaces must always have a parent.\n\nA main surface with its sub-surfaces forms a (compound) window.\nFor window management purposes, this set of wl_surface objects i o be considered as a single window, and it should also behave a uch.\n\nThe aim of sub-surfaces is to offload some of the compositing wor ithin a window from clients to the compositor. A prime example i  video player with decorations and video in separate wl_surfac bjects. This should allow the compositor to pass YUV video buffe rocessing to dedicated overlay hardware when possible."
                },
                {
                    "title": "wl_subsurface",
                    "text": "An additional interface to a wl_surface object, which has bee ade a sub-surface. A sub-surface has one parent surface.  ub-surface's size and position are not limited to that of the parent.\nParticularly, a sub-surface is not automatically clipped to it arent's area.\n\nA sub-surface becomes mapped, when a non-NULL wl_buffer is applie nd the parent surface is mapped. The order of which one happen irst is irrelevant. A sub-surface is hidden if the parent become idden, or if a NULL wl_buffer is applied. These rules appl ecursively through the tree of surfaces.\n\nThe behaviour of a wl_surface.commit request on a sub-surfac epends on the sub-surface's mode. The possible modes ar ynchronized and desynchronized, see method l_subsurface.set_sync and wl_subsurface.set_desync. Synchronize ode caches the wl_surface state to be applied when the parent' tate gets applied, and desynchronized mode applies the pendin l_surface state directly. A sub-surface is initially in th ynchronized mode.\n\nSub-surfaces also have another kind of state, which is managed b l_subsurface requests, as opposed to wl_surface requests. Thi tate includes the sub-surface position relative to the paren urface (wl_subsurface.set_position), and the stacking order o he parent and its sub-surfaces (wl_subsurface.place_above and\n.place_below). This state is applied when the parent surface' l_surface state is applied, regardless of the sub-surface's mode.\nAs the exception, set_sync and set_desync are effective immediately.\n\nThe main surface can be thought to be always in desynchronized mode,\nsince it does not have a parent in the sub-surfaces sense.\n\nEven if a sub-surface is in desynchronized mode, it will behave a n synchronized mode, if its parent surface behaves as i ynchronized mode. This rule is applied recursively throughout th ree of surfaces. This means, that one can set a sub-surface int ynchronized mode, and then assume that all its child and grand-chil ub-surfaces are synchronized, too, without explicitly setting them.\n\nDestroying a sub-surface takes effect immediately. If you need t ynchronize the removal of a sub-surface to the parent surface update,\nunmap the sub-surface first by attaching a NULL wl_buffer, update parent,\nand then destroy the sub-surface.\n\nIf the parent wl_surface object is destroyed, the sub-surface i nmapped.\n\nA sub-surface never has the keyboard focus of any seat.\n\nThe wl_surface.offset request is ignored: clients must use set_positio nstead to move the sub-surface."
                },
                {
                    "title": "wl_fixes",
                    "text": "This global fixes problems with other core-protocol interfaces tha annot be fixed in these interfaces themselves."
                }
            ],
            "tags": {
                "source": "core",
                "stability": "stable"
            },
            "source": "core",
            "supportIf": {
                "wl_compositor": {
                    "mutter": 1,
                    "kwin": 1,
                    "sway": 1,
                    "cosmic": 1,
                    "hyprland": 1,
                    "niri": 1,
                    "weston": 1,
                    "labwc": 1,
                    "cage": 1,
                    "wayfire": 1,
                    "gamescope": 1,
                    "jay": 1,
                    "mir": 1,
                    "treeland": 1,
                    "louvre": 1
                },
                "wl_data_device_manager": {
                    "mutter": 1,
                    "kwin": 1,
                    "sway": 1,
                    "cosmic": 1,
                    "hyprland": 1,
                    "niri": 1,
                    "weston": 1,
                    "labwc": 1,
                    "cage": 1,
                    "wayfire": 1,
                    "jay": 1,
                    "mir": 1,
                    "treeland": 1,
                    "louvre": 1
                },
                "wl_output": {
                    "mutter": 1,
                    "kwin": 1,
                    "sway": 1,
                    "cosmic": 1,
                    "hyprland": 1,
                    "niri": 1,
                    "weston": 1,
                    "labwc": 1,
                    "cage": 1,
                    "wayfire": 1,
                    "gamescope": 1,
                    "jay": 1,
                    "mir": 1,
                    "treeland": 1,
                    "louvre": 1
                },
                "wl_seat": {
                    "mutter": 1,
                    "kwin": 1,
                    "sway": 1,
                    "cosmic": 1,
                    "hyprland": 1,
                    "niri": 1,
                    "weston": 1,
                    "labwc": 1,
                    "cage": 1,
                    "wayfire": 1,
                    "gamescope": 1,
                    "jay": 1,
                    "mir": 1,
                    "treeland": 1,
                    "louvre": 1
                },
                "wl_shm": {
                    "mutter": 1,
                    "kwin": 1,
                    "sway": 1,
                    "cosmic": 1,
                    "hyprland": 1,
                    "niri": 1,
                    "weston": 1,
                    "labwc": 1,
                    "cage": 1,
                    "wayfire": 1,
                    "gamescope": 1,
                    "jay": 1,
                    "mir": 1,
                    "treeland": 1,
                    "louvre": 1
                },
                "wl_subcompositor": {
                    "mutter": 1,
                    "kwin": 1,
                    "sway": 1,
                    "cosmic": 1,
                    "hyprland": 1,
                    "niri": 1,
                    "weston": 1,
                    "labwc": 1,
                    "cage": 1,
                    "wayfire": 1,
                    "jay": 1,
                    "mir": 1,
                    "treeland": 1,
                    "louvre": 1
                },
                "wl_fixes": {
                    "jay": 1
                },
                "wl_shell": {
                    "mir": 1
                }
            },
            "supportSum": {
                "mutter": "partial",
                "kwin": "partial",
                "sway": "partial",
                "cosmic": "partial",
                "hyprland": "partial",
                "niri": "partial",
                "weston": "partial",
                "labwc": "partial",
                "cage": "partial",
                "wayfire": "partial",
                "gamescope": "partial",
                "jay": "partial",
                "mir": "partial",
                "treeland": "partial",
                "louvre": "partial"
            },
            "defaultExpand": true,
            "deprecations": {
                "wl_shell": "Use xdg-shell",
                "wl_shell_surface": "Use xdg-shell"
            }
        },
        {
            "id": "presentation-time",
            "name": "Presentation time",
            "descFull": [
                {
                    "title": "wp_presentation",
                    "text": "The main feature of this interface is accurate presentatio iming feedback to ensure smooth video playback while maintainin udio/video synchronization. Some features use the concept of  resentation clock, which is defined in th resentation.clock_id event.\n\nA content update for a wl_surface is submitted by  l_surface.commit request. Request 'feedback' associates wit he wl_surface.commit and provides feedback on the conten pdate, particularly the final realized presentation time.\n\n\n\nWhen the final realized presentation time is available, e.g.\nafter a framebuffer flip completes, the requeste resentation_feedback.presented events are sent. The fina resentation time can differ from the compositor's predicte isplay update time and the update's target time, especiall hen the compositor misses its target vertical blanking period."
                },
                {
                    "title": "wp_presentation_feedback",
                    "text": "A presentation_feedback object returns an indication that  l_surface content update has become visible to the user.\nOne object corresponds to one content update submission\n(wl_surface.commit). There are two possible outcomes: th ontent update is presented to the user, and a presentatio imestamp delivered; or, the user did not see the conten pdate because it was superseded or its surface destroyed,\nand the content update is discarded.\n\nOnce a presentation_feedback object has delivered a 'presented'\nor 'discarded' event it is automatically destroyed."
                }
            ],
            "tags": {
                "source": "wayland",
                "stability": "stable"
            },
            "source": "wayland-protocols",
            "supportIf": {
                "wp_presentation": {
                    "mutter": 1,
                    "kwin": 1,
                    "sway": 1,
                    "cosmic": 1,
                    "hyprland": 1,
                    "niri": 1,
                    "weston": 1,
                    "labwc": 1,
                    "cage": 1,
                    "wayfire": 1,
                    "gamescope": 1,
                    "jay": 1,
                    "louvre": 1
                }
            },
            "supportSum": {
                "mutter": "full",
                "kwin": "full",
                "sway": "full",
                "cosmic": "full",
                "hyprland": "full",
                "niri": "full",
                "weston": "full",
                "labwc": "full",
                "cage": "full",
                "wayfire": "full",
                "gamescope": "full",
                "jay": "full",
                "louvre": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "viewporter",
            "name": "Viewporter",
            "descFull": [
                {
                    "title": "wp_viewporter",
                    "text": "The global interface exposing surface cropping and scalin apabilities is used to instantiate an interface extension for  l_surface object. This extended interface will then allo ropping and scaling the surface contents, effectivel isconnecting the direct relationship between the buffer and th urface size."
                },
                {
                    "title": "wp_viewport",
                    "text": "An additional interface to a wl_surface object, which allows th lient to specify the cropping and scaling of the surfac ontents.\n\nThis interface works with two concepts: the source rectangle (src_x,\nsrc_y, src_width, src_height), and the destination size (dst_width,\ndst_height). The contents of the source rectangle are scaled to th estination size, and content outside the source rectangle is ignored.\nThis state is double-buffered, see wl_surface.commit.\n\nThe two parts of crop and scale state are independent: the sourc ectangle, and the destination size. Initially both are unset, tha s, no scaling is applied. The whole of the current wl_buffer i sed as the source, and the surface size is as defined i l_surface.attach.\n\nIf the destination size is set, it causes the surface size to becom st_width, dst_height. The source (rectangle) is scaled to exactl his size. This overrides whatever the attached wl_buffer size is,\nunless the wl_buffer is NULL. If the wl_buffer is NULL, the surfac as no content and therefore no size. Otherwise, the size is alway t least 1x1 in surface local coordinates.\n\nIf the source rectangle is set, it defines what area of the wl_buffer i aken as the source. If the source rectangle is set and the destinatio ize is not set, then src_width and src_height must be integers, and th urface size becomes the source rectangle size. This results in croppin ithout scaling. If src_width or src_height are not integers an estination size is not set, the bad_size protocol error is raised whe he surface state is applied.\n\nThe coordinate transformations from buffer pixel coordinates up t he surface-local coordinates happen in the following order:\n1. buffer_transform (wl_surface.set_buffer_transform)\n2. buffer_scale (wl_surface.set_buffer_scale)\n3. crop and scale (wp_viewport.set*)\nThis means, that the source rectangle coordinates of crop and scal re given in the coordinates after the buffer transform and scale,\ni.e. in the coordinates that would be the surface-local coordinate f the crop and scale was not applied.\n\nIf src_x or src_y are negative, the bad_value protocol error is raised.\nOtherwise, if the source rectangle is partially or completely outside o he non-NULL wl_buffer, then the out_of_buffer protocol error is raise hen the surface state is applied. A NULL wl_buffer does not raise th ut_of_buffer error.\n\nIf the wl_surface associated with the wp_viewport is destroyed,\nall wp_viewport requests except 'destroy' raise the protocol erro o_surface.\n\nIf the wp_viewport object is destroyed, the crop and scal tate is removed from the wl_surface. The change will be applie n the next wl_surface.commit."
                }
            ],
            "tags": {
                "source": "wayland",
                "stability": "stable"
            },
            "source": "wayland-protocols",
            "supportIf": {
                "wp_viewporter": {
                    "mutter": 1,
                    "kwin": 1,
                    "sway": 1,
                    "cosmic": 1,
                    "hyprland": 1,
                    "niri": 1,
                    "weston": 1,
                    "labwc": 1,
                    "cage": 1,
                    "wayfire": 1,
                    "jay": 1,
                    "mir": 1,
                    "treeland": 1,
                    "louvre": 1
                }
            },
            "supportSum": {
                "mutter": "full",
                "kwin": "full",
                "sway": "full",
                "cosmic": "full",
                "hyprland": "full",
                "niri": "full",
                "weston": "full",
                "labwc": "full",
                "cage": "full",
                "wayfire": "full",
                "jay": "full",
                "mir": "full",
                "treeland": "full",
                "louvre": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "xdg-shell",
            "name": "XDG shell",
            "descFull": [
                {
                    "title": "xdg_wm_base",
                    "text": "The xdg_wm_base interface is exposed as a global object enabling client o turn their wl_surfaces into windows in a desktop environment. I efines the basic functionality needed for clients and the compositor t reate windows that can be dragged, resized, maximized, etc, as well a reating transient windows such as popup menus."
                },
                {
                    "title": "xdg_positioner",
                    "text": "The xdg_positioner provides a collection of rules for the placement of  hild surface relative to a parent surface. Rules can be defined to ensur he child surface remains within the visible area's borders, and t pecify how the child surface changes its position, such as sliding alon n axis, or flipping around a rectangle. These positioner-created rules ar onstrained by the requirement that a child surface must intersect with o e at least partially adjacent to its parent surface.\n\nSee the various requests for details about possible rules.\n\nAt the time of the request, the compositor makes a copy of the rule pecified by the xdg_positioner. Thus, after the request is complete th dg_positioner object can be destroyed or reused; further changes to th bject will have no effect on previous usages.\n\nFor an xdg_positioner object to be considered complete, it must have  on-zero size set by set_size, and a non-zero anchor rectangle set b et_anchor_rect. Passing an incomplete xdg_positioner object whe ositioning a surface raises an invalid_positioner error."
                },
                {
                    "title": "xdg_surface",
                    "text": "An interface that may be implemented by a wl_surface, fo mplementations that provide a desktop-style user interface.\n\nIt provides a base set of functionality required to construct use nterface elements requiring management by the compositor, such a oplevel windows, menus, etc. The types of functionality are split int dg_surface roles.\n\nCreating an xdg_surface does not set the role for a wl_surface. In orde o map an xdg_surface, the client must create a role-specific objec sing, e.g., get_toplevel, get_popup. The wl_surface for any give dg_surface can have at most one role, and may not be assigned any rol ot based on xdg_surface.\n\nA role must be assigned before any other requests are made to th dg_surface object.\n\nThe client must call wl_surface.commit on the corresponding wl_surfac or the xdg_surface state to take effect.\n\nCreating an xdg_surface from a wl_surface which has a buffer attached o ommitted is a client error, and any attempts by a client to attach o anipulate a buffer prior to the first xdg_surface.configure call mus lso be treated as errors.\n\nAfter creating a role-specific object and setting it up (e.g. by sendin he title, app ID, size constraints, parent, etc), the client mus erform an initial commit without any buffer attached. The composito ill reply with initial wl_surface state such a l_surface.preferred_buffer_scale followed by an xdg_surface.configur vent. The client must acknowledge it and is then allowed to attach  uffer to map the surface.\n\nMapping an xdg_surface-based role surface is defined as making i ossible for the surface to be shown by the compositor. Note tha  mapped surface is not guaranteed to be visible once it is mapped.\n\nFor an xdg_surface to be mapped by the compositor, the followin onditions must be met:\n(1) the client has assigned an xdg_surface-based role to the surface\n(2) the client has set and committed the xdg_surface state and th ole-dependent state to the surface\n(3) the client has committed a buffer to the surface\n\nA newly-unmapped surface is considered to have met condition (1) ou f the 3 required conditions for mapping a surface if its role surfac as not been destroyed, i.e. the client must perform the initial commi gain before attaching a buffer."
                },
                {
                    "title": "xdg_toplevel",
                    "text": "This interface defines an xdg_surface role which allows a surface to,\namong other things, set window-like properties such as maximize,\nfullscreen, and minimize, set application-specific metadata like title an d, and well as trigger user interactive operations such as interactiv esize and move.\n\nA xdg_toplevel by default is responsible for providing the full intende isual representation of the toplevel, which depending on the windo tate, may mean things like a title bar, window controls and drop shadow.\n\nUnmapping an xdg_toplevel means that the surface cannot be show y the compositor until it is explicitly mapped again.\nAll active operations (e.g., move, resize) are canceled and al ttributes (e.g. title, state, stacking, ...) are discarded fo n xdg_toplevel surface when it is unmapped. The xdg_toplevel returns t he state it had right after xdg_surface.get_toplevel. The clien an re-map the toplevel by performing a commit without any buffe ttached, waiting for a configure event and handling it as usual (se dg_surface description).\n\nAttaching a null buffer to a toplevel unmaps the surface."
                },
                {
                    "title": "xdg_popup",
                    "text": "A popup surface is a short-lived, temporary surface. It can be used t mplement for example menus, popovers, tooltips and other similar use nterface concepts.\n\nA popup can be made to take an explicit grab. See xdg_popup.grab fo etails.\n\nWhen the popup is dismissed, a popup_done event will be sent out, and a he same time the surface will be unmapped. See the xdg_popup.popup_don vent for details.\n\nExplicitly destroying the xdg_popup object will also dismiss the popup an nmap the surface. Clients that want to dismiss the popup when anothe urface of their own is clicked should dismiss the popup using the destro equest.\n\nA newly created xdg_popup will be stacked on top of all previously create dg_popup surfaces associated with the same xdg_toplevel.\n\nThe parent of an xdg_popup must be mapped (see the xdg_surfac escription) before the xdg_popup itself.\n\nThe client must call wl_surface.commit on the corresponding wl_surfac or the xdg_popup state to take effect."
                }
            ],
            "tags": {
                "source": "wayland",
                "stability": "stable"
            },
            "source": "wayland-protocols",
            "supportIf": {
                "xdg_wm_base": {
                    "mutter": 1,
                    "kwin": 1,
                    "sway": 1,
                    "cosmic": 1,
                    "hyprland": 1,
                    "niri": 1,
                    "weston": 1,
                    "labwc": 1,
                    "cage": 1,
                    "wayfire": 1,
                    "gamescope": 1,
                    "jay": 1,
                    "mir": 1,
                    "treeland": 1,
                    "louvre": 1
                }
            },
            "supportSum": {
                "mutter": "full",
                "kwin": "full",
                "sway": "full",
                "cosmic": "full",
                "hyprland": "full",
                "niri": "full",
                "weston": "full",
                "labwc": "full",
                "cage": "full",
                "wayfire": "full",
                "gamescope": "full",
                "jay": "full",
                "mir": "full",
                "treeland": "full",
                "louvre": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "linux-dmabuf-v1",
            "name": "Linux DMA-BUF",
            "descFull": [
                {
                    "title": "zwp_linux_dmabuf_v1",
                    "text": "This interface offers ways to create generic dmabuf-based wl_buffers.\n\nFor more information about dmabuf, see:\nhttps://www.kernel.org/doc/html/next/userspace-api/dma-buf-alloc-exchange.html\n\nClients can use the get_surface_feedback request to get dmabuf feedbac or a particular surface. If the client wants to retrieve feedback no ied to a surface, they can use the get_default_feedback request.\n\nThe following are required from clients:\n\n- Clients must ensure that either all data in the dma-buf i oherent for all subsequent read access or that coherency i orrectly handled by the underlying kernel-side dma-bu mplementation.\n\n- Don't make any more attachments after sending the buffer to th ompositor. Making more attachments later increases the risk o he compositor not being able to use (re-import) an existin mabuf-based wl_buffer.\n\nThe underlying graphics stack must ensure the following:\n\n- The dmabuf file descriptors relayed to the server will stay vali or the whole lifetime of the wl_buffer. This means the server ma t any time use those fds to import the dmabuf into any kerne ub-system that might accept it.\n\nHowever, when the underlying graphics stack fails to deliver th romise, because of e.g. a device hot-unplug which raises interna rrors, after the wl_buffer has been successfully created th ompositor must not raise protocol errors to the client when dmabu mport later fails.\n\nTo create a wl_buffer from one or more dmabufs, a client creates  wp_linux_dmabuf_params_v1 object with a zwp_linux_dmabuf_v1.create_param equest. All planes required by the intended format are added wit he 'add' request. Finally, a 'create' or 'create_immed' request i ssued, which has the following outcome depending on the import success.\n\nThe 'create' request,\n- on success, triggers a 'created' event which provides the fina l_buffer to the client.\n- on failure, triggers a 'failed' event to convey that the serve annot use the dmabufs received from the client.\n\nFor the 'create_immed' request,\n- on success, the server immediately imports the added dmabufs t reate a wl_buffer. No event is sent from the server in this case.\n- on failure, the server can choose to either:\n- terminate the client by raising a fatal error.\n- mark the wl_buffer as failed, and send a 'failed' event to th lient. If the client uses a failed wl_buffer as an argument to an equest, the behaviour is compositor implementation-defined.\n\nFor all DRM formats and unless specified in another protocol extension,\npre-multiplied alpha is used for pixel values.\n\nUnless specified otherwise in another protocol extension, implici ynchronization is used. In other words, compositors and clients mus ait and signal fences implicitly passed via the DMA-BUF's reservatio echanism."
                },
                {
                    "title": "zwp_linux_buffer_params_v1",
                    "text": "This temporary object is a collection of dmabufs and othe arameters that together form a single logical buffer. The temporar bject may eventually create one wl_buffer unless cancelled b estroying it before requesting 'create'.\n\nSingle-planar formats only require one dmabuf, howeve ulti-planar formats may require more than one dmabuf. For al ormats, an 'add' request must be called once per plane (even if th nderlying dmabuf fd is identical).\n\nYou must use consecutive plane indices ('plane_idx' argument for 'add')\nfrom zero to the number of planes used by the drm_fourcc format code.\nAll planes required by the format must be given exactly once, but ca e given in any order. Each plane index can only be set once; subsequen alls with a plane index which has already been set will result in  lane_set error being generated."
                },
                {
                    "title": "zwp_linux_dmabuf_feedback_v1",
                    "text": "This object advertises dmabuf parameters feedback. This includes th referred devices and the supported formats/modifiers.\n\nThe parameters are sent once when this object is created and whenever the hange. The done event is always sent once after all parameters have bee ent. When a single parameter changes, all parameters are re-sent by th ompositor.\n\nCompositors can re-send the parameters when the current client buffe llocations are sub-optimal. Compositors should not re-send th arameters if re-allocating the buffers would not result in a more optima onfiguration. In particular, compositors should avoid sending the exac ame parameters multiple times in a row.\n\nThe tranche_target_device and tranche_formats events are grouped b ranches of preference. For each tranche, a tranche_target_device, on ranche_flags and one or more tranche_formats events are sent, followe y a tranche_done event finishing the list. The tranches are sent i escending order of preference. All formats and modifiers in the sam ranche have the same preference.\n\nTo send parameters, the compositor sends one main_device event, tranches\n(each consisting of one tranche_target_device event, one tranche_flag vent, tranche_formats events and then a tranche_done event), then on one event."
                }
            ],
            "tags": {
                "source": "wayland",
                "stability": "stable"
            },
            "source": "wayland-protocols",
            "supportIf": {
                "zwp_linux_dmabuf_v1": {
                    "mutter": 1,
                    "kwin": 1,
                    "sway": 1,
                    "cosmic": 1,
                    "hyprland": 1,
                    "niri": 1,
                    "weston": 1,
                    "labwc": 1,
                    "cage": 1,
                    "wayfire": 1,
                    "gamescope": 1,
                    "jay": 1,
                    "mir": 1,
                    "treeland": 1,
                    "louvre": 1
                }
            },
            "supportSum": {
                "mutter": "full",
                "kwin": "full",
                "sway": "full",
                "cosmic": "full",
                "hyprland": "full",
                "niri": "full",
                "weston": "full",
                "labwc": "full",
                "cage": "full",
                "wayfire": "full",
                "gamescope": "full",
                "jay": "full",
                "mir": "full",
                "treeland": "full",
                "louvre": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "tablet-v2",
            "name": "Tablet",
            "desc": "Wayland protocol for graphics tablets",
            "descFull": [
                {
                    "title": "Tablet",
                    "text": "This description provides a high-level overview of the interplay betwee he interfaces defined this protocol. For details, see the protoco pecification.\n\nMore than one tablet may exist, and device-specifics matter. Tablets ar ot represented by a single virtual device like wl_pointer. A clien inds to the tablet manager object which is just a proxy object. Fro hat, the client requests wp_tablet_manager.get_tablet_seat(wl_seat)\nand that returns the actual interface that has all the tablets. Wit his indirection, we can avoid merging wp_tablet into the actual Waylan rotocol, a long-term benefit.\n\nThe wp_tablet_seat sends a \"tablet added\" event for each table onnected. That event is followed by descriptive events about th ardware; currently that includes events for name, vid/pid an  wp_tablet.path event that describes a local path. This path can b sed to uniquely identify a tablet or get more information throug ibwacom. Emulated or nested tablets can skip any of those, e.g.  irtual tablet may not have a vid/pid. The sequence of descriptiv vents is terminated by a wp_tablet.done event to signal that a clien ay now finalize any initialization for that tablet.\n\nEvents from tablets require a tool in proximity. Tools are also manage y the tablet seat; a \"tool added\" event is sent whenever a tool is ne o the compositor. That event is followed by a number of descriptiv vents about the hardware; currently that includes capabilities,\nhardware id and serial number, and tool type. Similar to the table nterface, a wp_tablet_tool.done event is sent to terminate that initia equence.\n\nAny event from a tool happens on the wp_tablet_tool interface. When th ool gets into proximity of the tablet, a proximity_in event is sent o he wp_tablet_tool interface, listing the tablet and the surface. Tha vent is followed by a motion event with the coordinates. After that,\nit's the usual motion, axis, button, etc. events. The protocol' erialisation means events are grouped by wp_tablet_tool.frame events.\n\nTwo special events (that don't exist in X) are down and up. They signal\n\"tip touching the surface\". For tablets without real proximit etection, the sequence is: proximity_in, motion, down, frame.\n\nWhen the tool leaves proximity, a proximity_out event is sent. If an utton is still down, a button release event is sent before thi roximity event. These button events are sent in the same frame as th roximity event to signal to the client that the buttons were held whe he tool left proximity.\n\nIf the tool moves out of the surface but stays in proximity (i.e.\nbetween windows), compositor-specific grab policies apply. This usuall eans that the proximity-out is delayed until all buttons are released.\n\nMoving a tool physically from one tablet to the other has no real effec n the protocol, since we already have the tool object from the \"too dded\" event. All the information is already there and the proximit vents on both tablets are all a client needs to reconstruct wha appened.\n\nSome extra axes are normalized, i.e. the client knows the range a pecified in the protocol (e.g. [0, 65535]), the granularity however i nknown. The current normalized axes are pressure, distance, and slider.\n\nOther extra axes are in physical units as specified in the protocol.\nThe current extra axes with physical units are tilt, rotation an heel rotation.\n\nSince tablets work independently of the pointer controlled by the mouse,\nthe focus handling is independent too and controlled by proximity.\nThe wp_tablet_tool.set_cursor request sets a tool-specific cursor.\nThis cursor surface may be the same as the mouse cursor, and it may b he same across tools but it is possible to be more fine-grained. Fo xample, a client may set different cursors for the pen and eraser.\n\nTools are generally independent of tablets and it i ompositor-specific policy when a tool can be removed. Common approache ill likely include some form of removing a tool when all tablets th ool was used on are removed."
                },
                {
                    "title": "zwp_tablet_manager_v2",
                    "text": "An object that provides access to the graphics tablets available on thi ystem. All tablets are associated with a seat, to get access to th ctual tablets, use wp_tablet_manager.get_tablet_seat."
                },
                {
                    "title": "zwp_tablet_seat_v2",
                    "text": "An object that provides access to the graphics tablets available on thi eat. After binding to this interface, the compositor sends a set o p_tablet_seat.tablet_added and wp_tablet_seat.tool_added events."
                },
                {
                    "title": "zwp_tablet_tool_v2",
                    "text": "An object that represents a physical tool that has been, or i urrently in use with a tablet in this seat. Each wp_tablet_too bject stays valid until the client destroys it; the composito euses the wp_tablet_tool object to indicate that the object' espective physical tool has come into proximity of a tablet again.\n\nA wp_tablet_tool object's relation to a physical tool depends on th ablet's ability to report serial numbers. If the tablet support his capability, then the object represents a specific physical too nd can be identified even when used on multiple tablets.\n\nA tablet tool has a number of static characteristics, e.g. tool type,\nhardware_serial and capabilities. These capabilities are sent in a vent sequence after the wp_tablet_seat.tool_added event before an ctual events from this tool. This initial event sequence i erminated by a wp_tablet_tool.done event.\n\nTablet tool events are grouped by wp_tablet_tool.frame events.\nAny events received before a wp_tablet_tool.frame event should b onsidered part of the same hardware state change."
                },
                {
                    "title": "zwp_tablet_v2",
                    "text": "The wp_tablet interface represents one graphics tablet device. Th ablet interface itself does not generate events; all events ar enerated by wp_tablet_tool objects when in proximity above a tablet.\n\nA tablet has a number of static characteristics, e.g. device name an id/vid. These capabilities are sent in an event sequence after th p_tablet_seat.tablet_added event. This initial event sequence i erminated by a wp_tablet.done event."
                },
                {
                    "title": "zwp_tablet_pad_ring_v2",
                    "text": "A circular interaction area, such as the touch ring on the Wacom Intuo ro series tablets.\n\nEvents on a ring are logically grouped by the wl_tablet_pad_ring.fram vent."
                },
                {
                    "title": "zwp_tablet_pad_strip_v2",
                    "text": "A linear interaction area, such as the strips found in Wacom Cinti odels.\n\nEvents on a strip are logically grouped by the wl_tablet_pad_strip.fram vent."
                },
                {
                    "title": "zwp_tablet_pad_group_v2",
                    "text": "A pad group describes a distinct (sub)set of buttons, rings and strip resent in the tablet. The criteria of this grouping is usually positional,\neg. if a tablet has buttons on the left and right side, 2 groups will b resented. The physical arrangement of groups is undisclosed and ma hange on the fly.\n\nPad groups will announce their features during pad initialization. Betwee he corresponding wp_tablet_pad.group event and wp_tablet_pad_group.done, th ad group will announce the buttons, rings and strips contained in it,\nplus the number of supported modes.\n\nModes are a mechanism to allow multiple groups of actions for every elemen n the pad group. The number of groups and available modes in each i ersistent across device plugs. The current mode is user-switchable, i ill be announced through the wp_tablet_pad_group.mode_switch event bot henever it is switched, and after wp_tablet_pad.enter.\n\nThe current mode logically applies to all elements in the pad group,\nalthough it is at clients' discretion whether to actually perform differen ctions, and/or issue the respective .set_feedback requests to notify th ompositor. See the wp_tablet_pad_group.mode_switch event for more details."
                },
                {
                    "title": "zwp_tablet_pad_v2",
                    "text": "A pad device is a set of buttons, rings, strips and dial sually physically present on the tablet device itself. Som xceptions exist where the pad device is physically detached, e.g. th acom ExpressKey Remote.\n\nPad devices have no axes that control the cursor and are generall uxiliary devices to the tool devices used on the tablet surface.\n\nA pad device has a number of static characteristics, e.g. the numbe f rings. These capabilities are sent in an event sequence after th p_tablet_seat.pad_added event before any actual events from this pad.\nThis initial event sequence is terminated by a wp_tablet_pad.don vent.\n\nAll pad features (buttons, rings, strips and dials) are logically divided int roups and all pads have at least one group. The available groups ar otified through the wp_tablet_pad.group event; the compositor wil mit one event per group before emitting wp_tablet_pad.done.\n\nGroups may have multiple modes. Modes allow clients to map multipl ctions to a single pad feature. Only one mode can be active per group,\nalthough different groups may have different active modes."
                },
                {
                    "title": "zwp_tablet_pad_dial_v2",
                    "text": "A rotary control, e.g. a dial or a wheel.\n\nEvents on a dial are logically grouped by the wl_tablet_pad_dial.fram vent."
                }
            ],
            "tags": {
                "source": "wayland",
                "stability": "stable"
            },
            "source": "wayland-protocols",
            "supportIf": {
                "zwp_tablet_manager_v2": {
                    "mutter": 1,
                    "kwin": 1,
                    "sway": 1,
                    "cosmic": 1,
                    "hyprland": 1,
                    "niri": 1,
                    "labwc": 1,
                    "wayfire": 1,
                    "jay": 1
                }
            },
            "supportSum": {
                "mutter": "full",
                "kwin": "full",
                "sway": "full",
                "cosmic": "full",
                "hyprland": "full",
                "niri": "full",
                "labwc": "full",
                "wayfire": "full",
                "jay": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "xdg-activation-v1",
            "name": "XDG activation",
            "desc": "Protocol for requesting activation of surfaces",
            "descFull": [
                {
                    "title": "XDG activation",
                    "text": "The way for a client to pass focus to another toplevel is as follows.\n\nThe client that intends to activate another toplevel uses th dg_activation_v1.get_activation_token request to get an activation token.\nThis token is then forwarded to the client, which is supposed to activat ne of its surfaces, through a separate band of communication.\n\nOne established way of doing this is through the XDG_ACTIVATION_TOKE nvironment variable of a newly launched child process. The child proces hould unset the environment variable again right after reading it out i rder to avoid propagating it to other child processes.\n\nAnother established way exists for Applications implementing the D-Bu nterface org.freedesktop.Application, which should get their token unde ctivation-token on their platform_data.\n\nIn general activation tokens may be transferred across clients throug eans not described in this protocol.\n\nThe client to be activated will then pass the toke t received to the xdg_activation_v1.activate request. The compositor ca hen use this token to decide how to react to the activation request.\n\nThe token the activating client gets may be ineffective either already a he time it receives it, for example if it was not focused, for focu tealing prevention. The activating client will have no way to discove he validity of the token, and may still forward it to the to be activate lient.\n\nThe created activation token may optionally get information attached to i hat can be used by the compositor to identify the application that w ntend to activate. This can for example be used to display a visual hin bout what application is being started.\n\nWarning! The protocol described in this file is currently in the testin hase. Backward compatible changes may be added together with th orresponding interface version bump. Backward incompatible changes ca nly be done by creating a new major version of the extension."
                },
                {
                    "title": "xdg_activation_v1",
                    "text": "A global interface used for informing the compositor about application eing activated or started, or for applications to request to b ctivated."
                },
                {
                    "title": "xdg_activation_token_v1",
                    "text": "An object for setting up a token and receiving a token handle that ca e passed as an activation token to another client.\n\nThe object is created using the xdg_activation_v1.get_activation_toke equest. This object should then be populated with the app_id, surfac nd serial information and committed. The compositor shall then issue  one event with the token. In case the request's parameters are invalid,\nthe compositor will provide an invalid token."
                }
            ],
            "tags": {
                "source": "wayland",
                "stability": "staging"
            },
            "source": "wayland-protocols",
            "supportIf": {
                "xdg_activation_v1": {
                    "mutter": 1,
                    "kwin": 1,
                    "sway": 1,
                    "cosmic": 1,
                    "hyprland": 1,
                    "niri": 1,
                    "labwc": 1,
                    "wayfire": 1,
                    "jay": 1,
                    "mir": 1,
                    "louvre": 1
                }
            },
            "supportSum": {
                "mutter": "full",
                "kwin": "full",
                "sway": "full",
                "cosmic": "full",
                "hyprland": "full",
                "niri": "full",
                "labwc": "full",
                "wayfire": "full",
                "jay": "full",
                "mir": "full",
                "louvre": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "drm-lease-v1",
            "name": "DRM lease",
            "descFull": [
                {
                    "title": "wp_drm_lease_device_v1",
                    "text": "This protocol is used by Wayland compositors which act as Direc endering Manager (DRM) masters to lease DRM resources to Waylan lients.\n\nThe compositor will advertise one wp_drm_lease_device_v1 global for eac RM node. Some time after a client binds to the wp_drm_lease_device_v lobal, the compositor will send a drm_fd event followed by zero, one o ore connector events. After all currently available connectors have bee ent, the compositor will send a wp_drm_lease_device_v1.done event.\n\nWhen the list of connectors available for lease changes the composito ill send wp_drm_lease_device_v1.connector events for added connectors an p_drm_lease_connector_v1.withdrawn events for removed connectors,\nfollowed by a wp_drm_lease_device_v1.done event.\n\nThe compositor will indicate when a device is gone by removing the globa ia a wl_registry.global_remove event. Upon receiving this event, th lient should destroy any matching wp_drm_lease_device_v1 object.\n\nTo destroy a wp_drm_lease_device_v1 object, the client must first issu  release request. Upon receiving this request, the compositor wil mmediately send a released event and destroy the object. The client mus ontinue to process and discard drm_fd and connector events until i eceives the released event. Upon receiving the released event, th lient can safely cleanup any client-side resources.\n\nWarning! The protocol described in this file is currently in the testin hase. Backward compatible changes may be added together with th orresponding interface version bump. Backward incompatible changes ca nly be done by creating a new major version of the extension."
                },
                {
                    "title": "wp_drm_lease_connector_v1",
                    "text": "Represents a DRM connector which is available for lease. These objects ar reated via wp_drm_lease_device_v1.connector events, and should be passe o lease requests via wp_drm_lease_request_v1.request_connector.\nImmediately after the wp_drm_lease_connector_v1 object is created th ompositor will send a name, a description, a connector_id and a don vent. When the description is updated the compositor will send  escription event followed by a done event."
                },
                {
                    "title": "wp_drm_lease_request_v1",
                    "text": "A client that wishes to lease DRM resources will attach the list o onnectors advertised with wp_drm_lease_device_v1.connector that the ish to lease, then use wp_drm_lease_request_v1.submit to submit th equest."
                },
                {
                    "title": "wp_drm_lease_v1",
                    "text": "A DRM lease object is used to transfer the DRM file descriptor to th lient and manage the lifetime of the lease.\n\nSome time after the wp_drm_lease_v1 object is created, the composito ill reply with the lease request's result. If the lease request i ranted, the compositor will send a lease_fd event. If the lease reques s denied, the compositor will send a finished event without a lease_f vent."
                }
            ],
            "tags": {
                "source": "wayland",
                "stability": "staging"
            },
            "source": "wayland-protocols",
            "supportIf": {
                "wp_drm_lease_device_v1": {
                    "mutter": 1,
                    "kwin": 1,
                    "cosmic": 1,
                    "hyprland": 1,
                    "niri": 1,
                    "labwc": 1,
                    "wayfire": 1,
                    "jay": 1,
                    "louvre": 1
                }
            },
            "supportSum": {
                "mutter": "full",
                "kwin": "full",
                "cosmic": "full",
                "hyprland": "full",
                "niri": "full",
                "labwc": "full",
                "wayfire": "full",
                "jay": "full",
                "louvre": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "linux-drm-syncobj-v1",
            "name": "DRM synchronization object",
            "desc": "protocol for providing explicit synchronization",
            "descFull": [
                {
                    "title": "DRM synchronization object",
                    "text": "This protocol allows clients to request explicit synchronization fo uffers. It is tied to the Linux DRM synchronization object framework.\n\nSynchronization refers to co-ordination of pipelined operations performe n buffers. Most GPU clients will schedule an asynchronous operation t ender to the buffer, then immediately send the buffer to the composito o be attached to a surface.\n\nWith implicit synchronization, ensuring that the rendering operation i omplete before the compositor displays the buffer is an implementatio etail handled by either the kernel or userspace graphics driver.\n\nBy contrast, with explicit synchronization, DRM synchronization objec imeline points mark when the asynchronous operations are complete. Whe ubmitting a buffer, the client provides a timeline point which will b aited on before the compositor accesses the buffer, and another timelin oint that the compositor will signal when it no longer needs to access th uffer contents for the purposes of the surface commit.\n\nLinux DRM synchronization objects are documented at:\nhttps://dri.freedesktop.org/docs/drm/gpu/drm-mm.html#drm-sync-objects\n\nWarning! The protocol described in this file is currently in the testin hase. Backward compatible changes may be added together with th orresponding interface version bump. Backward incompatible changes ca nly be done by creating a new major version of the extension."
                },
                {
                    "title": "wp_linux_drm_syncobj_manager_v1",
                    "text": "This global is a factory interface, allowing clients to reques xplicit synchronization for buffers on a per-surface basis.\n\nSee wp_linux_drm_syncobj_surface_v1 for more information."
                },
                {
                    "title": "wp_linux_drm_syncobj_timeline_v1",
                    "text": "This object represents an explicit synchronization object timelin mported by the client to the compositor."
                },
                {
                    "title": "wp_linux_drm_syncobj_surface_v1",
                    "text": "This object is an add-on interface for wl_surface to enable explici ynchronization.\n\nEach surface can be associated with only one object of this interface a ny time.\n\nExplicit synchronization is guaranteed to be supported for buffer reated with any version of the linux-dmabuf protocol. Compositors ar ree to support explicit synchronization for additional buffer types.\nIf at surface commit time the attached buffer does not support explici ynchronization, an unsupported_buffer error is raised.\n\nAs long as the wp_linux_drm_syncobj_surface_v1 object is alive, th ompositor may ignore implicit synchronization for buffers attached an ommitted to the wl_surface. The delivery of wl_buffer.release event or buffers attached to the surface becomes undefined.\n\nClients must set both acquire and release points if and only if  on-null buffer is attached in the same surface commit. See th o_buffer, no_acquire_point and no_release_point protocol errors.\n\nIf at surface commit time the acquire and release DRM syncobj timeline re identical, the acquire point value must be strictly less than th elease point value, or else the conflicting_points protocol error i aised."
                }
            ],
            "tags": {
                "source": "wayland",
                "stability": "staging"
            },
            "source": "wayland-protocols",
            "supportIf": {
                "wp_linux_drm_syncobj_manager_v1": {
                    "mutter": 1,
                    "kwin": 1,
                    "hyprland": 1,
                    "gamescope": 1,
                    "jay": 1
                }
            },
            "supportSum": {
                "mutter": "full",
                "kwin": "full",
                "hyprland": "full",
                "gamescope": "full",
                "jay": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "ext-session-lock-v1",
            "name": "Session lock",
            "desc": "secure session locking with arbitrary graphics",
            "descFull": [
                {
                    "title": "Session lock",
                    "text": "This protocol allows for a privileged Wayland client to lock the sessio nd display arbitrary graphics while the session is locked.\n\nThe compositor may choose to restrict this protocol to a special clien aunched by the compositor itself or expose it to all privileged clients,\nthis is compositor policy.\n\nThe client is responsible for performing authentication and informing th ompositor when the session should be unlocked. If the client dies whil he session is locked the session remains locked, possibly permanentl epending on compositor policy.\n\nThe key words \"must\", \"must not\", \"required\", \"shall\", \"shall not\",\n\"should\", \"should not\", \"recommended\",  \"may\", and \"optional\" in thi ocument are to be interpreted as described in IETF RFC 2119.\n\nWarning! The protocol described in this file is currently in th esting phase. Backward compatible changes may be added together wit he corresponding interface version bump. Backward incompatible change an only be done by creating a new major version of the extension."
                },
                {
                    "title": "ext_session_lock_manager_v1",
                    "text": "This interface is used to request that the session be locked."
                },
                {
                    "title": "ext_session_lock_v1",
                    "text": "In response to the creation of this object the compositor must sen ither the locked or finished event.\n\nThe locked event indicates that the session is locked. This mean hat the compositor must stop rendering and providing input to norma lients. Instead the compositor must blank all outputs with an opaqu olor such that their normal content is fully hidden.\n\nThe only surfaces that should be rendered while the session is locke re the lock surfaces created through this interface and optionally,\nat the compositor's discretion, special privileged surfaces such a nput methods or portions of desktop shell UIs.\n\nThe locked event must not be sent until a new \"locked\" frame (eithe rom a session lock surface or the compositor blanking the output) ha een presented on all outputs and no security sensitive normal/unlocke ontent is possibly visible.\n\nThe finished event should be sent immediately on creation of thi bject if the compositor decides that the locked event will not be sent.\n\nThe compositor may wait for the client to create and render session loc urfaces before sending the locked event to avoid displaying intermediat lank frames. However, it must impose a reasonable time limit i aiting and send the locked event as soon as the hard requirement escribed above can be met if the time limit expires. Clients shoul mmediately create lock surfaces for all outputs on creation of thi bject to make this possible.\n\nThis behavior of the locked event is required in order to preven ossible race conditions with clients that wish to suspend the syste r similar after locking the session. Without these semantics, client riggering a suspend after receiving the locked event would race wit he first \"locked\" frame being presented and normal/unlocked frame ight be briefly visible as the system is resumed if the suspen peration wins the race.\n\nIf the client dies while the session is locked, the compositor must no nlock the session in response. It is acceptable for the session to b ermanently locked if this happens. The compositor may choose to continu o display the lock surfaces the client had mapped before it died o lternatively fall back to a solid color, this is compositor policy.\n\nCompositors may also allow a secure way to recover the session, th etails of this are compositor policy. Compositors may allow a ne lient to create a ext_session_lock_v1 object and take responsibilit or unlocking the session, they may even start a new lock clien nstance automatically."
                },
                {
                    "title": "ext_session_lock_surface_v1",
                    "text": "The client may use lock surfaces to display a screensaver, render  ialog to enter a password and unlock the session, or however else i ees fit.\n\nOn binding this interface the compositor will immediately send th irst configure event. After making the ack_configure request i esponse to this event the client should attach and commit the firs uffer. Committing the surface before acking the first configure is  rotocol error. Committing the surface with a null buffer at any tim s a protocol error.\n\nThe compositor is free to handle keyboard/pointer focus for loc urfaces however it chooses. A reasonable way to do this would be t ive the first lock surface created keyboard focus and change keyboar ocus if the user clicks on other surfaces."
                }
            ],
            "tags": {
                "source": "wayland",
                "stability": "staging"
            },
            "source": "wayland-protocols",
            "supportIf": {
                "ext_session_lock_manager_v1": {
                    "sway": 1,
                    "cosmic": 1,
                    "hyprland": 1,
                    "niri": 1,
                    "labwc": 1,
                    "wayfire": 1,
                    "jay": 1,
                    "mir": 1,
                    "louvre": 1
                }
            },
            "supportSum": {
                "sway": "full",
                "cosmic": "full",
                "hyprland": "full",
                "niri": "full",
                "labwc": "full",
                "wayfire": "full",
                "jay": "full",
                "mir": "full",
                "louvre": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "single-pixel-buffer-v1",
            "name": "Single-pixel buffer",
            "desc": "single pixel buffer factory",
            "descFull": [
                {
                    "title": "Single-pixel buffer",
                    "text": "This protocol extension allows clients to create single-pixel buffers.\n\nCompositors supporting this protocol extension should also support th iewporter protocol extension. Clients may use viewporter to scale  ingle-pixel buffer to a desired size.\n\nWarning! The protocol described in this file is currently in the testin hase. Backward compatible changes may be added together with th orresponding interface version bump. Backward incompatible changes ca nly be done by creating a new major version of the extension."
                },
                {
                    "title": "wp_single_pixel_buffer_manager_v1",
                    "text": "The wp_single_pixel_buffer_manager_v1 interface is a factory fo ingle-pixel buffers."
                }
            ],
            "tags": {
                "source": "wayland",
                "stability": "staging"
            },
            "source": "wayland-protocols",
            "supportIf": {
                "wp_single_pixel_buffer_manager_v1": {
                    "mutter": 1,
                    "sway": 1,
                    "cosmic": 1,
                    "hyprland": 1,
                    "weston": 1,
                    "labwc": 1,
                    "cage": 1,
                    "wayfire": 1,
                    "jay": 1,
                    "louvre": 1
                }
            },
            "supportSum": {
                "mutter": "full",
                "sway": "full",
                "cosmic": "full",
                "hyprland": "full",
                "weston": "full",
                "labwc": "full",
                "cage": "full",
                "wayfire": "full",
                "jay": "full",
                "louvre": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "content-type-v1",
            "name": "Content type hint",
            "descFull": [
                {
                    "title": "wp_content_type_manager_v1",
                    "text": "This interface allows a client to describe the kind of content a surfac ill display, to allow the compositor to optimize its behavior for it.\n\nWarning! The protocol described in this file is currently in the testin hase. Backward compatible changes may be added together with th orresponding interface version bump. Backward incompatible changes ca nly be done by creating a new major version of the extension."
                },
                {
                    "title": "wp_content_type_v1",
                    "text": "The content type object allows the compositor to optimize for the kin f content shown on the surface. A compositor may for example use it t et relevant drm properties like \"content type\".\n\nThe client may request to switch to another content type at any time.\nWhen the associated surface gets destroyed, this object becomes inert an he client should destroy it."
                }
            ],
            "tags": {
                "source": "wayland",
                "stability": "staging"
            },
            "source": "wayland-protocols",
            "supportIf": {
                "wp_content_type_manager_v1": {
                    "kwin": 1,
                    "sway": 1,
                    "hyprland": 1,
                    "jay": 1,
                    "louvre": 1
                }
            },
            "supportSum": {
                "kwin": "full",
                "sway": "full",
                "hyprland": "full",
                "jay": "full",
                "louvre": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "ext-idle-notify-v1",
            "name": "Idle notify",
            "descFull": [
                {
                    "title": "ext_idle_notifier_v1",
                    "text": "This interface allows clients to monitor user idle status.\n\nAfter binding to this global, clients can create ext_idle_notification_v bjects to get notified when the user is idle for a given amount of time."
                },
                {
                    "title": "ext_idle_notification_v1",
                    "text": "This interface is used by the compositor to send idle notification event o clients.\n\nInitially the notification object is not idle. The notification objec ecomes idle when no user activity has happened for at least the timeou uration, starting from the creation of the notification object. Use ctivity may include input events or a presence sensor, but i ompositor-specific.\n\nHow this notification responds to idle inhibitors depends on ho t was constructed. If constructed from th et_idle_notification request, then if an idle inhibitor i ctive (e.g. another client has created a zwp_idle_inhibitor_v n a visible surface), the compositor must not make th otification object idle. However, if constructed from th et_input_idle_notification request, then idle inhibitors ar gnored, and only input from the user, e.g. from a keyboard o ouse, counts as activity.\n\nWhen the notification object becomes idle, an idled event is sent. Whe ser activity starts again, the notification object stops being idle,\na resumed event is sent and the timeout is restarted."
                }
            ],
            "tags": {
                "source": "wayland",
                "stability": "staging"
            },
            "source": "wayland-protocols",
            "supportIf": {
                "ext_idle_notifier_v1": {
                    "kwin": 1,
                    "sway": 1,
                    "cosmic": 1,
                    "hyprland": 1,
                    "niri": 1,
                    "labwc": 1,
                    "cage": 1,
                    "wayfire": 1,
                    "jay": 1,
                    "treeland": 1,
                    "louvre": 1
                }
            },
            "supportSum": {
                "kwin": "full",
                "sway": "full",
                "cosmic": "full",
                "hyprland": "full",
                "niri": "full",
                "labwc": "full",
                "cage": "full",
                "wayfire": "full",
                "jay": "full",
                "treeland": "full",
                "louvre": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "ext-image-capture-source-v1",
            "name": "Image Capture Source",
            "desc": "opaque image capture source objects",
            "descFull": [
                {
                    "title": "Image Capture Source",
                    "text": "This protocol serves as an intermediary between capturing protocols an otential image capture sources such as outputs and toplevels.\n\nThis protocol may be extended to support more image capture sources in th uture, thereby adding those image capture sources to other protocols tha se the image capture source object without having to modify thos rotocols.\n\nWarning! The protocol described in this file is currently in the testin hase. Backward compatible changes may be added together with th orresponding interface version bump. Backward incompatible changes ca nly be done by creating a new major version of the extension."
                },
                {
                    "title": "ext_image_capture_source_v1",
                    "text": "The image capture source object is an opaque descriptor for a capturabl esource.  This resource may be any sort of entity from which an imag ay be derived.\n\nNote, because ext_image_capture_source_v1 objects are created from multipl ndependent factory interfaces, the ext_image_capture_source_v1 interface i rozen at version 1."
                },
                {
                    "title": "ext_output_image_capture_source_manager_v1",
                    "text": "A manager for creating image capture source objects for wl_output objects."
                },
                {
                    "title": "ext_foreign_toplevel_image_capture_source_manager_v1",
                    "text": "A manager for creating image capture source objects fo xt_foreign_toplevel_handle_v1 objects."
                }
            ],
            "tags": {
                "source": "wayland",
                "stability": "staging"
            },
            "source": "wayland-protocols",
            "supportIf": {
                "ext_foreign_toplevel_image_capture_source_manager_v1": {
                    "jay": 1,
                    "louvre": 1
                },
                "ext_output_image_capture_source_manager_v1": {
                    "jay": 1,
                    "louvre": 1
                }
            },
            "supportSum": {
                "jay": "full",
                "louvre": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "ext-image-copy-capture-v1",
            "name": "Image Copy Capture",
            "desc": "image capturing into client buffers",
            "descFull": [
                {
                    "title": "Image Copy Capture",
                    "text": "This protocol allows clients to ask the compositor to capture image source uch as outputs and toplevels into user submitted buffers.\n\nWarning! The protocol described in this file is currently in the testin hase. Backward compatible changes may be added together with th orresponding interface version bump. Backward incompatible changes ca nly be done by creating a new major version of the extension."
                },
                {
                    "title": "ext_image_copy_capture_manager_v1",
                    "text": "This object is a manager which offers requests to start capturing from  ource."
                },
                {
                    "title": "ext_image_copy_capture_session_v1",
                    "text": "This object represents an active image copy capture session.\n\nAfter a capture session is created, buffer constraint events will b mitted from the compositor to tell the client which buffer types an ormats are supported for reading from the session. The compositor ma e-send buffer constraint events whenever they change.\n\nTo advertise buffer constraints, the compositor must send in n articular order: zero or more shm_format and dmabuf_format events, zer r one dmabuf_device event, and exactly one buffer_size event. Then th ompositor must send a done event.\n\nWhen the client has received all the buffer constraints, it can create  uffer accordingly, attach it to the capture session using th ttach_buffer request, set the buffer damage using the damage_buffe equest and then send the capture request."
                },
                {
                    "title": "ext_image_copy_capture_frame_v1",
                    "text": "This object represents an image capture frame.\n\nThe client should attach a buffer, damage the buffer, and then send  apture request.\n\nIf the capture is successful, the compositor must send the frame metadata\n(transform, damage, presentation_time in any order) followed by the read vent.\n\nIf the capture fails, the compositor must send the failed event."
                },
                {
                    "title": "ext_image_copy_capture_cursor_session_v1",
                    "text": "This object represents a cursor capture session. It extends the bas apture session with cursor-specific metadata."
                }
            ],
            "tags": {
                "source": "wayland",
                "stability": "staging"
            },
            "source": "wayland-protocols",
            "supportIf": {
                "ext_image_copy_capture_manager_v1": {
                    "jay": 1
                }
            },
            "supportSum": {
                "jay": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "tearing-control-v1",
            "name": "Tearing control",
            "descFull": [
                {
                    "title": "wp_tearing_control_manager_v1",
                    "text": "For some use cases like games or drawing tablets it can make sense t educe latency by accepting tearing with the use of asynchronous pag lips. This global is a factory interface, allowing clients to infor hich type of presentation the content of their surfaces is suitable for.\n\nGraphics APIs like EGL or Vulkan, that manage the buffer queue and commit f a wl_surface themselves, are likely to be using this extensio nternally. If a client is using such an API for a wl_surface, it shoul ot directly use this extension on that surface, to avoid raising  earing_control_exists protocol error.\n\nWarning! The protocol described in this file is currently in the testin hase. Backward compatible changes may be added together with th orresponding interface version bump. Backward incompatible changes ca nly be done by creating a new major version of the extension."
                },
                {
                    "title": "wp_tearing_control_v1",
                    "text": "An additional interface to a wl_surface object, which allows the clien o hint to the compositor if the content on the surface is suitable fo resentation with tearing.\nThe default presentation hint is vsync. See presentation_hint for mor etails.\n\nIf the associated wl_surface is destroyed, this object becomes inert an hould be destroyed."
                }
            ],
            "tags": {
                "source": "wayland",
                "stability": "staging"
            },
            "source": "wayland-protocols",
            "supportIf": {
                "wp_tearing_control_manager_v1": {
                    "kwin": 1,
                    "sway": 1,
                    "hyprland": 1,
                    "weston": 1,
                    "labwc": 1,
                    "jay": 1,
                    "louvre": 1
                }
            },
            "supportSum": {
                "kwin": "full",
                "sway": "full",
                "hyprland": "full",
                "weston": "full",
                "labwc": "full",
                "jay": "full",
                "louvre": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "xwayland-shell-v1",
            "name": "Xwayland shell",
            "desc": "Protocol for associating X11 windows to wl_surfaces",
            "descFull": [
                {
                    "title": "Xwayland shell",
                    "text": "This protocol adds a xwayland_surface role which allows an Xwaylan erver to associate an X11 window to a wl_surface.\n\nBefore this protocol, this would be done via the Xwayland serve roviding the wl_surface's resource id via the a client message wit he WL_SURFACE_ID atom on the X window.\nThis was problematic as a race could occur if the wl_surfac ssociated with a WL_SURFACE_ID for a window was destroyed before th lient message was processed by the compositor and another surface\n(or other object) had taken its id due to recycling.\n\nThis protocol solves the problem by moving the X11 window to wl_surfac ssociation step to the Wayland side, which means that the associatio annot happen out-of-sync with the resource lifetime of the wl_surface.\n\nThis protocol avoids duplicating the race on the other side by adding  on-zero monotonic serial number which is entirely unique that is set o oth the wl_surface (via. xwayland_surface_v1's set_serial method) an he X11 window (via. the `WL_SURFACE_SERIAL` client message) that can b sed to associate them, and synchronize the two timelines.\n\nThe key words \"must\", \"must not\", \"required\", \"shall\", \"shall not\",\n\"should\", \"should not\", \"recommended\",  \"may\", and \"optional\" in thi ocument are to be interpreted as described in IETF RFC 2119.\n\nWarning! The protocol described in this file is currently in the testin hase. Backward compatible changes may be added together with th orresponding interface version bump. Backward incompatible changes ca nly be done by creating a new major version of the extension."
                },
                {
                    "title": "xwayland_shell_v1",
                    "text": "xwayland_shell_v1 is a singleton global object tha rovides the ability to create a xwayland_surface_v1 objec or a given wl_surface.\n\nThis interface is intended to be bound by the Xwayland server.\n\nA compositor must not allow clients other than Xwayland t ind to this interface. A compositor should hide this globa rom other clients' wl_registry.\nA client the compositor does not consider to be an Xwaylan erver attempting to bind this interface will result i n implementation-defined error.\n\nAn Xwayland server that has bound this interface must no et the `WL_SURFACE_ID` atom on a window."
                },
                {
                    "title": "xwayland_surface_v1",
                    "text": "An Xwayland surface is a surface managed by an Xwayland server.\nIt is used for associating surfaces to Xwayland windows.\n\nThe Xwayland server associated with actions in this interface i etermined by the Wayland client making the request.\n\nThe client must call wl_surface.commit on the corresponding wl_surfac or the xwayland_surface_v1 state to take effect."
                }
            ],
            "tags": {
                "source": "wayland",
                "stability": "staging"
            },
            "source": "wayland-protocols",
            "supportIf": {
                "xwayland_shell_v1": {
                    "hyprland": 1,
                    "cage": 1,
                    "wayfire": 1
                }
            },
            "supportSum": {
                "hyprland": "full",
                "cage": "full",
                "wayfire": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "fractional-scale-v1",
            "name": "Fractional scale",
            "desc": "Protocol for requesting fractional surface scales",
            "descFull": [
                {
                    "title": "Fractional scale",
                    "text": "This protocol allows a compositor to suggest for surfaces to render a ractional scales.\n\nA client can submit scaled content by utilizing wp_viewport. This is done b reating a wp_viewport object for the surface and setting the destinatio ectangle to the surface size before the scale factor is applied.\n\nThe buffer size is calculated by multiplying the surface size by th ntended scale.\n\nThe wl_surface buffer scale should remain set to 1.\n\nIf a surface has a surface-local size of 100 px by 50 px and wishes t ubmit buffers with a scale of 1.5, then a buffer of 150px by 75 px shoul e used and the wp_viewport destination rectangle should be 100 px by 50 px.\n\nFor toplevel surfaces, the size is rounded halfway away from zero. Th ounding algorithm for subsurface position and size is not defined."
                },
                {
                    "title": "wp_fractional_scale_manager_v1",
                    "text": "A global interface for requesting surfaces to use fractional scales."
                },
                {
                    "title": "wp_fractional_scale_v1",
                    "text": "An additional interface to a wl_surface object which allows the composito o inform the client of the preferred scale."
                }
            ],
            "tags": {
                "source": "wayland",
                "stability": "staging"
            },
            "source": "wayland-protocols",
            "supportIf": {
                "wp_fractional_scale_manager_v1": {
                    "mutter": 1,
                    "kwin": 1,
                    "sway": 1,
                    "cosmic": 1,
                    "hyprland": 1,
                    "niri": 1,
                    "labwc": 1,
                    "wayfire": 1,
                    "jay": 1,
                    "mir": 1,
                    "treeland": 1,
                    "louvre": 1
                }
            },
            "supportSum": {
                "mutter": "full",
                "kwin": "full",
                "sway": "full",
                "cosmic": "full",
                "hyprland": "full",
                "niri": "full",
                "labwc": "full",
                "wayfire": "full",
                "jay": "full",
                "mir": "full",
                "treeland": "full",
                "louvre": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "cursor-shape-v1",
            "name": "Cursor shape",
            "descFull": [
                {
                    "title": "wp_cursor_shape_manager_v1",
                    "text": "This global offers an alternative, optional way to set cursor images. Thi ew way uses enumerated cursors instead of a wl_surface lik l_pointer.set_cursor does.\n\nWarning! The protocol described in this file is currently in the testin hase. Backward compatible changes may be added together with th orresponding interface version bump. Backward incompatible changes ca nly be done by creating a new major version of the extension."
                },
                {
                    "title": "wp_cursor_shape_device_v1",
                    "text": "This interface allows clients to set the cursor shape."
                }
            ],
            "tags": {
                "source": "wayland",
                "stability": "staging"
            },
            "source": "wayland-protocols",
            "supportIf": {
                "wp_cursor_shape_manager_v1": {
                    "mutter": 1,
                    "kwin": 1,
                    "sway": 1,
                    "cosmic": 1,
                    "hyprland": 1,
                    "niri": 1,
                    "labwc": 1,
                    "jay": 1,
                    "treeland": 1
                }
            },
            "supportSum": {
                "mutter": "full",
                "kwin": "full",
                "sway": "full",
                "cosmic": "full",
                "hyprland": "full",
                "niri": "full",
                "labwc": "full",
                "jay": "full",
                "treeland": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "ext-foreign-toplevel-list-v1",
            "name": "Foreign toplevel list",
            "desc": "list toplevels",
            "descFull": [
                {
                    "title": "Foreign toplevel list",
                    "text": "The purpose of this protocol is to provide protocol object handles fo oplevels, possibly originating from another client.\n\nThis protocol is intentionally minimalistic and expects additiona unctionality (e.g. creating a screencopy source from a toplevel handle,\ngetting information about the state of the toplevel) to be implemente n extension protocols.\n\nThe compositor may choose to restrict this protocol to a special clien aunched by the compositor itself or expose it to all clients,\nthis is compositor policy.\n\nThe key words \"must\", \"must not\", \"required\", \"shall\", \"shall not\",\n\"should\", \"should not\", \"recommended\",  \"may\", and \"optional\" in thi ocument are to be interpreted as described in IETF RFC 2119.\n\nWarning! The protocol described in this file is currently in the testin hase. Backward compatible changes may be added together with th orresponding interface version bump. Backward incompatible changes ca nly be done by creating a new major version of the extension."
                },
                {
                    "title": "ext_foreign_toplevel_list_v1",
                    "text": "A toplevel is defined as a surface with a role similar to xdg_toplevel.\nXWayland surfaces may be treated like toplevels in this protocol.\n\nAfter a client binds the ext_foreign_toplevel_list_v1, each mappe oplevel window will be sent using the ext_foreign_toplevel_list_v1.topleve vent.\n\nClients which only care about the current state can perform a roundtrip afte inding this global.\n\nFor each instance of ext_foreign_toplevel_list_v1, the compositor mus reate a new ext_foreign_toplevel_handle_v1 object for each mapped toplevel.\n\nIf a compositor implementation sends the ext_foreign_toplevel_list_v1.finishe vent after the global is bound, the compositor must not send an xt_foreign_toplevel_list_v1.toplevel events."
                },
                {
                    "title": "ext_foreign_toplevel_handle_v1",
                    "text": "A ext_foreign_toplevel_handle_v1 object represents a mapped topleve indow. A single app may have multiple mapped toplevels."
                }
            ],
            "tags": {
                "source": "wayland",
                "stability": "staging"
            },
            "source": "wayland-protocols",
            "supportIf": {
                "ext_foreign_toplevel_list_v1": {
                    "sway": 1,
                    "cosmic": 1,
                    "hyprland": 1,
                    "labwc": 1,
                    "jay": 1,
                    "louvre": 1
                }
            },
            "supportSum": {
                "sway": "full",
                "cosmic": "full",
                "hyprland": "full",
                "labwc": "full",
                "jay": "full",
                "louvre": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "security-context-v1",
            "name": "Security context",
            "descFull": [
                {
                    "title": "wp_security_context_manager_v1",
                    "text": "This interface allows a client to register a new Wayland connection t he compositor and attach a security context to it.\n\nThis is intended to be used by sandboxes. Sandbox engines attach  ecurity context to all connections coming from inside the sandbox. Th ompositor can then restrict the features that the sandboxed connection an use.\n\nCompositors should forbid nesting multiple security contexts by no xposing wp_security_context_manager_v1 global to clients with a securit ontext attached, or by sending the nested protocol error. Neste ecurity contexts are dangerous because they can potentially allo rivilege escalation of a sandboxed client.\n\nWarning! The protocol described in this file is currently in the testin hase. Backward compatible changes may be added together with th orresponding interface version bump. Backward incompatible changes ca nly be done by creating a new major version of the extension."
                },
                {
                    "title": "wp_security_context_v1",
                    "text": "The security context allows a client to register a new client and attac ecurity context metadata to the connections.\n\nWhen both are set, the combination of the application ID and the sandbo ngine must uniquely identify an application. The same application I ill be used across instances (e.g. if the application is restarted, o f the application is started multiple times).\n\nWhen both are set, the combination of the instance ID and the sandbo ngine must uniquely identify a running instance of an application."
                }
            ],
            "tags": {
                "source": "wayland",
                "stability": "staging"
            },
            "source": "wayland-protocols",
            "supportIf": {
                "wp_security_context_manager_v1": {
                    "kwin": 1,
                    "sway": 1,
                    "cosmic": 1,
                    "hyprland": 1,
                    "niri": 1,
                    "labwc": 1,
                    "jay": 1
                }
            },
            "supportSum": {
                "kwin": "full",
                "sway": "full",
                "cosmic": "full",
                "hyprland": "full",
                "niri": "full",
                "labwc": "full",
                "jay": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "ext-transient-seat-v1",
            "name": "Transient seat",
            "desc": "protocol for creating temporary seats",
            "descFull": [
                {
                    "title": "Transient seat",
                    "text": "The transient seat protocol can be used by privileged clients to creat ndependent seats that will be removed from the compositor when the clien estroys its transient seat.\n\nThis protocol is intended for use with virtual input protocols such as\n\"virtual_keyboard_unstable_v1\" or \"wlr_virtual_pointer_unstable_v1\", bot f which allow the user to select a seat.\n\nThe \"wl_seat\" global created by this protocol does not generate input event n its own, or have any capabilities except those assigned to it by othe rotocol extensions, such as the ones mentioned above.\n\nFor example, a remote desktop server can create a seat with virtual input or each remote user by following these steps for each new connection:\n* Create a transient seat\n* Wait for the transient seat to be created\n* Locate a \"wl_seat\" global with a matching name\n* Create virtual inputs using the resulting \"wl_seat\" global"
                },
                {
                    "title": "ext_transient_seat_manager_v1",
                    "text": "The transient seat manager creates short-lived seats."
                },
                {
                    "title": "ext_transient_seat_v1",
                    "text": "When the transient seat handle is destroyed, the seat itself will also b estroyed."
                }
            ],
            "tags": {
                "source": "wayland",
                "stability": "staging"
            },
            "source": "wayland-protocols",
            "supportIf": {
                "ext_transient_seat_manager_v1": {
                    "sway": 1,
                    "jay": 1
                }
            },
            "supportSum": {
                "sway": "full",
                "jay": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "xdg-toplevel-drag-v1",
            "name": "XDG toplevel drag",
            "descFull": [
                {
                    "title": "xdg_toplevel_drag_manager_v1",
                    "text": "This protocol enhances normal drag and drop with the ability to move  indow at the same time. This allows having detachable parts of a windo hat when dragged out of it become a new window and can be dragged ove n existing window to be reattached.\n\nA typical workflow would be when the user starts dragging on top of  etachable part of a window, the client would create a wl_data_source an  xdg_toplevel_drag_v1 object and start the drag as normal vi l_data_device.start_drag. Once the client determines that the detachabl indow contents should be detached from the originating window, it create  new xdg_toplevel with these contents and issues  dg_toplevel_drag_v1.attach request before mapping it. From now on the ne indow is moved by the compositor during the drag as if the client calle dg_toplevel.move.\n\nDragging an existing window is similar. The client creates  dg_toplevel_drag_v1 object and attaches the existing toplevel befor tarting the drag.\n\nClients use the existing drag and drop mechanism to detect when a windo an be docked or undocked. If the client wants to snap a window into  arent window it should delete or unmap the dragged top-level. If th ontents should be detached again it attaches a new toplevel as describe bove. If a drag operation is cancelled without being dropped, client hould revert to the previous state, deleting any newly created window s appropriate. When a drag operation ends as indicated b l_data_source.dnd_drop_performed the dragged toplevel window's fina osition is determined as if a xdg_toplevel_move operation ended.\n\nWarning! The protocol described in this file is currently in the testin hase. Backward compatible changes may be added together with th orresponding interface version bump. Backward incompatible changes ca nly be done by creating a new major version of the extension."
                }
            ],
            "tags": {
                "source": "wayland",
                "stability": "staging"
            },
            "source": "wayland-protocols",
            "supportIf": {
                "xdg_toplevel_drag_manager_v1": {
                    "mutter": 1,
                    "kwin": 1,
                    "jay": 1
                }
            },
            "supportSum": {
                "mutter": "full",
                "kwin": "full",
                "jay": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "xdg-toplevel-icon-v1",
            "name": "XDG toplevel icon",
            "desc": "protocol to assign icons to toplevels",
            "descFull": [
                {
                    "title": "XDG toplevel icon",
                    "text": "This protocol allows clients to set icons for their toplevel surface ither via the XDG icon stock (using an icon name), or from pixel data.\n\nA toplevel icon represents the individual toplevel (unlike the applicatio r launcher icon, which represents the application as a whole), and may b hown in window switchers, window overviews and taskbars that lis ndividual windows.\n\nThis document adheres to RFC 2119 when using words like \"must\",\n\"should\", \"may\", etc.\n\nWarning! The protocol described in this file is currently in the testin hase. Backward compatible changes may be added together with th orresponding interface version bump. Backward incompatible changes ca nly be done by creating a new major version of the extension."
                },
                {
                    "title": "xdg_toplevel_icon_manager_v1",
                    "text": "This interface allows clients to create toplevel window icons and se hem on toplevel windows to be displayed to the user."
                },
                {
                    "title": "xdg_toplevel_icon_v1",
                    "text": "This interface defines a toplevel icon.\nAn icon can have a name, and multiple buffers.\nIn order to be applied, the icon must have either a name, or at leas ne buffer assigned. Applying an empty icon (with no buffer or name) t  toplevel should reset its icon to the default icon.\n\nIt is up to compositor policy whether to prefer using a buffer or loadin n icon via its name. See 'set_name' and 'add_buffer' for details."
                }
            ],
            "tags": {
                "source": "wayland",
                "stability": "staging"
            },
            "source": "wayland-protocols",
            "supportIf": {
                "xdg_toplevel_icon_manager_v1": {
                    "kwin": 1
                }
            },
            "supportSum": {
                "kwin": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "xdg-dialog-v1",
            "name": "XDG dialog windows",
            "descFull": [
                {
                    "title": "xdg_wm_dialog_v1",
                    "text": "The xdg_wm_dialog_v1 interface is exposed as a global object allowin o register surfaces with a xdg_toplevel role as \"dialogs\" relative t nother toplevel.\n\nThe compositor may let this relation influence how the surface i laced, displayed or interacted with.\n\nWarning! The protocol described in this file is currently in the testin hase. Backward compatible changes may be added together with th orresponding interface version bump. Backward incompatible changes ca nly be done by creating a new major version of the extension."
                },
                {
                    "title": "xdg_dialog_v1",
                    "text": "A xdg_dialog_v1 object is an ancillary object tied to a xdg_toplevel. It urpose is hinting the compositor that the toplevel is a \"dialog\" (e.g.  emporary window) relative to another toplevel (se dg_toplevel.set_parent). If the xdg_toplevel is destroyed, the xdg_dialog_v ecomes inert.\n\nThrough this object, the client may provide additional hints abou he purpose of the secondary toplevel. This interface has no effec n toplevels that are not attached to a parent toplevel."
                }
            ],
            "tags": {
                "source": "wayland",
                "stability": "staging"
            },
            "source": "wayland-protocols",
            "supportIf": {
                "xdg_wm_dialog_v1": {
                    "mutter": 1,
                    "kwin": 1,
                    "hyprland": 1,
                    "jay": 1
                }
            },
            "supportSum": {
                "mutter": "full",
                "kwin": "full",
                "hyprland": "full",
                "jay": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "alpha-modifier-v1",
            "name": "Alpha modifier protocol",
            "descFull": [
                {
                    "title": "wp_alpha_modifier_v1",
                    "text": "This interface allows a client to set a factor for the alpha values on  urface, which can be used to offload such operations to the compositor,\nwhich can in turn for example offload them to KMS.\n\nWarning! The protocol described in this file is currently in the testin hase. Backward compatible changes may be added together with th orresponding interface version bump. Backward incompatible changes ca nly be done by creating a new major version of the extension."
                },
                {
                    "title": "wp_alpha_modifier_surface_v1",
                    "text": "This interface allows the client to set a factor for the alpha values o  surface, which can be used to offload such operations to the compositor.\nThe default factor is UINT32_MAX.\n\nThis object has to be destroyed before the associated wl_surface. Once th l_surface is destroyed, all request on this object will raise th o_surface error."
                }
            ],
            "tags": {
                "source": "wayland",
                "stability": "staging"
            },
            "source": "wayland-protocols",
            "supportIf": {
                "wp_alpha_modifier_v1": {
                    "kwin": 1,
                    "sway": 1,
                    "cosmic": 1,
                    "hyprland": 1,
                    "jay": 1
                }
            },
            "supportSum": {
                "kwin": "full",
                "sway": "full",
                "cosmic": "full",
                "hyprland": "full",
                "jay": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "commit-timing-v1",
            "name": "Commit timing protocol",
            "descFull": [
                {
                    "title": "wp_commit_timing_manager_v1",
                    "text": "When a compositor latches on to new content updates it will check fo ny number of requirements of the available content updates (such a ences of all buffers being signalled) to consider the update ready.\n\nThis protocol provides a method for adding a time constraint to surfac ontent. This constraint indicates to the compositor that a conten pdate should be presented as closely as possible to, but not before,\na specified time.\n\nThis protocol does not change the Wayland property that conten pdates are applied in the order they are received, even when som ontent updates contain timestamps and others do not.\n\nTo provide timestamps, this global factory interface must be used t cquire a wp_commit_timing_v1 object for a surface, which may then b sed to provide timestamp information for commits.\n\nWarning! The protocol described in this file is currently in the testin hase. Backward compatible changes may be added together with th orresponding interface version bump. Backward incompatible changes ca nly be done by creating a new major version of the extension."
                },
                {
                    "title": "wp_commit_timer_v1",
                    "text": "An object to set a time constraint for a content update on a surface."
                }
            ],
            "tags": {
                "source": "wayland",
                "stability": "staging"
            },
            "source": "wayland-protocols",
            "supportIf": {
                "wp_commit_timing_manager_v1": {
                    "mutter": 1,
                    "jay": 1
                }
            },
            "supportSum": {
                "mutter": "full",
                "jay": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "ext-data-control-v1",
            "name": "Data control protocol",
            "desc": "control data devices",
            "descFull": [
                {
                    "title": "Data control protocol",
                    "text": "This protocol allows a privileged client to control data devices. I articular, the client will be able to manage the current selection and tak he role of a clipboard manager.\n\nWarning! The protocol described in this file is currently in the testin hase. Backward compatible changes may be added together with th orresponding interface version bump. Backward incompatible changes ca nly be done by creating a new major version of the extension."
                },
                {
                    "title": "ext_data_control_manager_v1",
                    "text": "This interface is a manager that allows creating per-seat data devic ontrols."
                },
                {
                    "title": "ext_data_control_device_v1",
                    "text": "This interface allows a client to manage a seat's selection.\n\nWhen the seat is destroyed, this object becomes inert."
                },
                {
                    "title": "ext_data_control_source_v1",
                    "text": "The ext_data_control_source object is the source side of  xt_data_control_offer. It is created by the source client in a dat ransfer and provides a way to describe the offered data and a way t espond to requests to transfer the data."
                },
                {
                    "title": "ext_data_control_offer_v1",
                    "text": "A ext_data_control_offer represents a piece of data offered for transfe y another client (the source client). The offer describes the differen IME types that the data can be converted to and provides the mechanis or transferring the data directly from the source client."
                }
            ],
            "tags": {
                "source": "wayland",
                "stability": "staging"
            },
            "source": "wayland-protocols",
            "supportIf": {
                "ext_data_control_manager_v1": {
                    "niri": 1,
                    "jay": 1
                }
            },
            "supportSum": {
                "niri": "full",
                "jay": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "fifo-v1",
            "name": "Fifo protocol",
            "descFull": [
                {
                    "title": "wp_fifo_manager_v1",
                    "text": "When a Wayland compositor considers applying a content update,\nit must ensure all the update's readiness constraints (fences, etc)\nare met.\n\nThis protocol provides a way to use the completion of a display refres ycle as an additional readiness constraint.\n\nWarning! The protocol described in this file is currently in the testin hase. Backward compatible changes may be added together with th orresponding interface version bump. Backward incompatible changes ca nly be done by creating a new major version of the extension."
                },
                {
                    "title": "wp_fifo_v1",
                    "text": "A fifo object for a surface that may be used to ad isplay refresh constraints to content updates."
                }
            ],
            "tags": {
                "source": "wayland",
                "stability": "staging"
            },
            "source": "wayland-protocols",
            "supportIf": {
                "wp_fifo_manager_v1": {
                    "mutter": 1,
                    "jay": 1
                }
            },
            "supportSum": {
                "mutter": "full",
                "jay": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "xdg-system-bell-v1",
            "name": "System bell protocol",
            "descFull": [
                {
                    "title": "xdg_system_bell_v1",
                    "text": "This global interface enables clients to ring the system bell.\n\nWarning! The protocol described in this file is currently in the testin hase. Backward compatible changes may be added together with th orresponding interface version bump. Backward incompatible changes ca nly be done by creating a new major version of the extension."
                }
            ],
            "tags": {
                "source": "wayland",
                "stability": "staging"
            },
            "source": "wayland-protocols",
            "supportIf": {
                "xdg_system_bell_v1": {
                    "mutter": 1,
                    "kwin": 1
                }
            },
            "supportSum": {
                "mutter": "full",
                "kwin": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "ext-workspace-v1",
            "name": "Workspace protocol",
            "descFull": [
                {
                    "title": "ext_workspace_manager_v1",
                    "text": "Workspaces, also called virtual desktops, are groups of surfaces.  ompositor with a concept of workspaces may only show some such groups o urfaces (those of 'active' workspaces) at a time.'Activating'  orkspace is a request for the compositor to display that workspace' urfaces as normal, whereas the compositor may hide or otherwis e-emphasise surfaces that are associated only with 'inactive' workspaces.\nWorkspaces are grouped by which sets of outputs they correspond to, an ay contain surfaces only from those outputs. In this way, it is possibl or each output to have its own set of workspaces, or for all outputs (o ny other arbitrary grouping) to share workspaces. Compositors ma ptionally conceptually arrange each group of workspaces in a -dimensional grid.\n\nThe purpose of this protocol is to enable the creation of taskbars an ocks by providing them with a list of workspaces and their properties,\nand allowing them to activate and deactivate workspaces.\n\nAfter a client binds the ext_workspace_manager_v1, each workspace will b ent via the workspace event."
                },
                {
                    "title": "ext_workspace_group_handle_v1",
                    "text": "A ext_workspace_group_handle_v1 object represents a workspace grou hat is assigned a set of outputs and contains a number of workspaces.\n\nThe set of outputs assigned to the workspace group is conveyed to the client vi utput_enter and output_leave events, and its workspaces are conveyed wit orkspace events.\n\nFor example, a compositor which has a set of workspaces for each output ma dvertise a workspace group (and its workspaces) per output, whereas a composito here a workspace spans all outputs may advertise a single workspace group for al utputs."
                },
                {
                    "title": "ext_workspace_handle_v1",
                    "text": "A ext_workspace_handle_v1 object represents a workspace that handles  roup of surfaces.\n\nEach workspace has:\n- a name, conveyed to the client with the name event\n- potentially an id conveyed with the id event\n- a list of states, conveyed to the client with the state event\n- and optionally a set of coordinates, conveyed to the client with th oordinates event\n\nThe client may request that the compositor activate or deactivate the workspace.\n\nEach workspace can belong to only a single workspace group.\nDepepending on the compositor policy, there might be workspaces wit he same name in different workspace groups, but these workspaces are stil eparate (e.g. one of them might be active while the other is not)."
                }
            ],
            "tags": {
                "source": "wayland",
                "stability": "staging"
            },
            "source": "wayland-protocols",
            "supportIf": {
                "ext_workspace_manager_v1": {
                    "labwc": 1,
                    "jay": 1
                }
            },
            "supportSum": {
                "labwc": "full",
                "jay": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "color-management-v1",
            "name": "Color management",
            "desc": "color management protocol",
            "descFull": [
                {
                    "title": "Color management",
                    "text": "The aim of the color management extension is to allow clients to kno he color properties of outputs, and to tell the compositor about the colo roperties of their content on surfaces. Doing this enables a composito o perform automatic color management of content for different output ccording to how content is intended to look like.\n\nThe color properties are represented as an image description object whic s immutable after it has been created. A wl_output always has a ssociated image description that clients can observe. A wl_surfac lways has an associated preferred image description as a hint chosen b he compositor that clients can also observe. Clients can set an imag escription on a wl_surface to denote the color characteristics of th urface contents.\n\nAn image description includes SDR and HDR colorimetry and encoding, HD etadata, and viewing environment parameters. An image description doe ot include the properties set through color-representation extension.\nIt is expected that the color-representation extension is used i onjunction with the color management extension when necessary,\nparticularly with the YUV family of pixel formats.\n\nRecommendation ITU-T H.273\n\"Coding-independent code points for video signal type identification\"\nshall be referred to as simply H.273 here.\n\nThe color-and-hdr repository\n(https://gitlab.freedesktop.org/pq/color-and-hdr) contain ackground information on the protocol design and legacy color management.\nIt also contains a glossary, learning resources for digital color, tools,\nsamples and more.\n\nThe terminology used in this protocol is based on common color science an olor encoding terminology where possible. The glossary in the color-and-hd epository shall be the authority on the definition of terms in thi rotocol.\n\nWarning! The protocol described in this file is currently in the testin hase. Backward compatible changes may be added together with th orresponding interface version bump. Backward incompatible changes ca nly be done by creating a new major version of the extension."
                },
                {
                    "title": "wp_color_manager_v1",
                    "text": "A singleton global interface used for getting color management extension or wl_surface and wl_output objects, and for creating client define mage description objects. The extension interfaces allo etting the image description of outputs and setting the imag escription of surfaces.\n\nCompositors should never remove this global."
                },
                {
                    "title": "wp_color_management_output_v1",
                    "text": "A wp_color_management_output_v1 describes the color properties of a utput.\n\nThe wp_color_management_output_v1 is associated with the wl_output globa nderlying the wl_output object. Therefore the client destroying th l_output object has no impact, but the compositor removing the outpu lobal makes the wp_color_management_output_v1 object inert."
                },
                {
                    "title": "wp_color_management_surface_v1",
                    "text": "A wp_color_management_surface_v1 allows the client to set the colo pace and HDR properties of a surface.\n\nIf the wl_surface associated with the wp_color_management_surface_v1 i estroyed, the wp_color_management_surface_v1 object becomes inert."
                },
                {
                    "title": "wp_color_management_surface_feedback_v1",
                    "text": "A wp_color_management_surface_feedback_v1 allows the client to get th referred image description of a surface.\n\nIf the wl_surface associated with this object is destroyed, th p_color_management_surface_feedback_v1 object becomes inert."
                },
                {
                    "title": "wp_image_description_creator_icc_v1",
                    "text": "This type of object is used for collecting all the information require o create a wp_image_description_v1 object from an ICC file. A complet et of required parameters consists of these properties:\n- ICC file\n\nEach required property must be set exactly once if the client is to creat n image description. The set requests verify that a property was no lready set. The create request verifies that all required properties ar et. There may be several alternative requests for setting each property,\nand in that case the client must choose one of them.\n\nOnce all properties have been set, the create request must be used t reate the image description object, destroying the creator in th rocess."
                },
                {
                    "title": "wp_image_description_creator_params_v1",
                    "text": "This type of object is used for collecting all the parameters require o create a wp_image_description_v1 object. A complete set of require arameters consists of these properties:\n- transfer characteristic function (tf)\n- chromaticities of primaries and white point (primary color volume)\n\nThe following properties are optional and have a well-defined defaul f not explicitly set:\n- primary color volume luminance range\n- reference white luminance level\n- mastering display primaries and white point (target color volume)\n- mastering luminance range\n\nThe following properties are optional and will be ignore f not explicitly set:\n- maximum content light level\n- maximum frame-average light level\n\nEach required property must be set exactly once if the client is to creat n image description. The set requests verify that a property was no lready set. The create request verifies that all required properties ar et. There may be several alternative requests for setting each property,\nand in that case the client must choose one of them.\n\nOnce all properties have been set, the create request must be used t reate the image description object, destroying the creator in th rocess."
                },
                {
                    "title": "wp_image_description_v1",
                    "text": "An image description carries information about the color encoding used o  surface when attached to a wl_surface vi p_color_management_surface_v1.set_image_description. A compositor can us his information to decode pixel values into colorimetrically meaningfu uantities.\n\nNote, that the wp_image_description_v1 object is not ready to be use mmediately after creation. The object eventually delivers either the\n'ready' or the 'failed' event, specified in all requests creating it. Th bject is deemed \"ready\" after receiving the 'ready' event.\n\nAn object which is not ready is illegal to use, it can only be destroyed.\nAny other request in this interface shall result in the 'not_ready'\nprotocol error. Attempts to use an object which is not ready through othe nterfaces shall raise protocol errors defined there.\n\nOnce created and regardless of how it was created,  p_image_description_v1 object always refers to one fixed imag escription. It cannot change after creation."
                },
                {
                    "title": "wp_image_description_info_v1",
                    "text": "Sends all matching events describing an image description object exactl nce and finally sends the 'done' event.\n\nThis means\n- if the image description is parametric, it must send\n- primaries\n- named_primaries, if applicable\n- at least one of tf_power and tf_named, as applicable\n- luminances\n- target_primaries\n- target_luminance\n- if the image description is parametric, it may send, if applicable,\n- target_max_cll\n- target_max_fall\n- if the image description contains an ICC profile, it must send th cc_file event\n\nOnce a wp_image_description_info_v1 object has delivered a 'done' event i s automatically destroyed.\n\nEvery wp_image_description_info_v1 created from the sam p_image_description_v1 shall always return the exact same data."
                }
            ],
            "tags": {
                "source": "wayland",
                "stability": "staging"
            },
            "source": "wayland-protocols",
            "supportIf": {
                "wp_color_manager_v1": {
                    "mutter": 1,
                    "hyprland": 1,
                    "jay": 1
                }
            },
            "supportSum": {
                "mutter": "full",
                "hyprland": "full",
                "jay": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "xdg-toplevel-tag-v1",
            "name": "XDG toplevel tag",
            "descFull": [
                {
                    "title": "xdg_toplevel_tag_manager_v1",
                    "text": "In order to make some window properties like position, size,\n\"always on top\" or user defined rules for window behavior persistent, th ompositor needs some way to identify windows even after the applicatio as been restarted.\nThis protocol allows clients to make this possible by setting a tag fo oplevels.\n\nWarning! The protocol described in this file is currently in the testin hase. Backward compatible changes may be added together with th orresponding interface version bump. Backward incompatible changes ca nly be done by creating a new major version of the extension."
                }
            ],
            "tags": {
                "source": "wayland",
                "stability": "staging"
            },
            "source": "wayland-protocols",
            "supportIf": {},
            "supportSum": {},
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "fullscreen-shell-unstable-v1",
            "name": "Fullscreen shell",
            "descFull": [
                {
                    "title": "zwp_fullscreen_shell_v1",
                    "text": "Displays a single surface per output.\n\nThis interface provides a mechanism for a single client to displa imple full-screen surfaces.  While there technically may be multipl lients bound to this interface, only one of those clients should b hown at a time.\n\nTo present a surface, the client uses either the present_surface o resent_surface_for_mode requests.  Presenting a surface takes effec n the next wl_surface.commit.  See the individual requests fo etails about scaling and mode switches.\n\nThe client can have at most one surface per output at any time.\nRequesting a surface to be presented on an output that already has  urface replaces the previously presented surface.  Presenting a nul urface removes its content and effectively disables the output.\nExactly what happens when an output is \"disabled\" i ompositor-specific.  The same surface may be presented on multipl utputs simultaneously.\n\nOnce a surface is presented on an output, it stays on that outpu ntil either the client removes it or the compositor destroys th utput.  This way, the client can update the output's contents b imply attaching a new buffer.\n\nWarning! The protocol described in this file is experimental an ackward incompatible changes may be made. Backward compatible change ay be added together with the corresponding interface version bump.\nBackward incompatible changes are done by bumping the version number i he protocol and interface names and resetting the interface version.\nOnce the protocol is to be declared stable, the 'z' prefix and th ersion number in the protocol and interface names are removed and th nterface version number is reset."
                }
            ],
            "tags": {
                "source": "wayland",
                "stability": "unstable"
            },
            "source": "wayland-protocols",
            "supportIf": {},
            "supportSum": {},
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "idle-inhibit-unstable-v1",
            "name": "Idle inhibit",
            "descFull": [
                {
                    "title": "zwp_idle_inhibit_manager_v1",
                    "text": "This interface permits inhibiting the idle behavior such as scree lanking, locking, and screensaving.  The client binds the idle manage lobally, then creates idle-inhibitor objects for each surface.\n\nWarning! The protocol described in this file is experimental an ackward incompatible changes may be made. Backward compatible change ay be added together with the corresponding interface version bump.\nBackward incompatible changes are done by bumping the version number i he protocol and interface names and resetting the interface version.\nOnce the protocol is to be declared stable, the 'z' prefix and th ersion number in the protocol and interface names are removed and th nterface version number is reset."
                },
                {
                    "title": "zwp_idle_inhibitor_v1",
                    "text": "An idle inhibitor prevents the output that the associated surface i isible on from being set to a state where it is not visually usable du o lack of user interaction (e.g. blanked, dimmed, locked, set to powe ave, etc.)  Any screensaver processes are also blocked from displaying.\n\nIf the surface is destroyed, unmapped, becomes occluded, lose isibility, or otherwise becomes not visually relevant for the user, th dle inhibitor will not be honored by the compositor; if the surfac ubsequently regains visibility the inhibitor takes effect once again.\nLikewise, the inhibitor isn't honored if the system was already idled a he time the inhibitor was established, although if the system late e-idles and re-idles the inhibitor will take effect."
                }
            ],
            "tags": {
                "source": "wayland",
                "stability": "unstable"
            },
            "source": "wayland-protocols",
            "supportIf": {
                "zwp_idle_inhibit_manager_v1": {
                    "mutter": 1,
                    "kwin": 1,
                    "sway": 1,
                    "cosmic": 1,
                    "hyprland": 1,
                    "niri": 1,
                    "labwc": 1,
                    "cage": 1,
                    "wayfire": 1,
                    "jay": 1,
                    "mir": 1,
                    "treeland": 1,
                    "louvre": 1
                }
            },
            "supportSum": {
                "mutter": "full",
                "kwin": "full",
                "sway": "full",
                "cosmic": "full",
                "hyprland": "full",
                "niri": "full",
                "labwc": "full",
                "cage": "full",
                "wayfire": "full",
                "jay": "full",
                "mir": "full",
                "treeland": "full",
                "louvre": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "input-method-unstable-v1",
            "name": "Input method v1",
            "descFull": [
                {
                    "title": "zwp_input_method_context_v1",
                    "text": "Corresponds to a text input on the input method side. An input method contex s created on text input activation on the input method side. It allow eceiving information about the text input from the application via events.\nInput method contexts do not keep state after deactivation and should b estroyed after deactivation is handled.\n\nText is generally UTF-8 encoded, indices and lengths are in bytes.\n\nSerials are used to synchronize the state between the text input an n input method. New serials are sent by the text input in th ommit_state request and are used by the input method to indicat he known text input state in events like preedit_string, commit_string,\nand keysym. The text input can then ignore events from the input metho hich are based on an outdated state (for example after a reset).\n\nWarning! The protocol described in this file is experimental an ackward incompatible changes may be made. Backward compatible change ay be added together with the corresponding interface version bump.\nBackward incompatible changes are done by bumping the version number i he protocol and interface names and resetting the interface version.\nOnce the protocol is to be declared stable, the 'z' prefix and th ersion number in the protocol and interface names are removed and th nterface version number is reset."
                },
                {
                    "title": "zwp_input_method_v1",
                    "text": "An input method object is responsible for composing text in response t nput from hardware or virtual keyboards. There is one input metho bject per seat. On activate there is a new input method context objec reated which allows the input method to communicate with the text input."
                },
                {
                    "title": "zwp_input_panel_v1",
                    "text": "Only one client can bind this interface at a time."
                }
            ],
            "tags": {
                "source": "wayland",
                "stability": "unstable"
            },
            "source": "wayland-protocols",
            "supportIf": {
                "zwp_input_method_v1": {
                    "weston": 1,
                    "mir": 1
                },
                "zwp_input_panel_v1": {
                    "weston": 1,
                    "mir": 1
                }
            },
            "supportSum": {
                "weston": "full",
                "mir": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "input-timestamps-unstable-v1",
            "name": "Input timestamps",
            "desc": "High-resolution timestamps for input events",
            "descFull": [
                {
                    "title": "Input timestamps",
                    "text": "This protocol specifies a way for a client to request and receiv igh-resolution timestamps for input events.\n\nWarning! The protocol described in this file is experimental an ackward incompatible changes may be made. Backward compatible change ay be added together with the corresponding interface version bump.\nBackward incompatible changes are done by bumping the version number i he protocol and interface names and resetting the interface version.\nOnce the protocol is to be declared stable, the 'z' prefix and th ersion number in the protocol and interface names are removed and th nterface version number is reset."
                },
                {
                    "title": "zwp_input_timestamps_manager_v1",
                    "text": "A global interface used for requesting high-resolution timestamp or input events."
                },
                {
                    "title": "zwp_input_timestamps_v1",
                    "text": "Provides high-resolution timestamp events for a set of subscribed inpu vents. The set of subscribed input events is determined by th wp_input_timestamps_manager_v1 request used to create this object."
                }
            ],
            "tags": {
                "source": "wayland",
                "stability": "unstable"
            },
            "source": "wayland-protocols",
            "supportIf": {
                "zwp_input_timestamps_manager_v1": {
                    "weston": 1
                }
            },
            "supportSum": {
                "weston": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "keyboard-shortcuts-inhibit-unstable-v1",
            "name": "Keyboard shortcuts inhibit",
            "desc": "Protocol for inhibiting the compositor keyboard shortcuts",
            "descFull": [
                {
                    "title": "Keyboard shortcuts inhibit",
                    "text": "This protocol specifies a way for a client to request the composito o ignore its own keyboard shortcuts for a given seat, so that al ey events from that seat get forwarded to a surface.\n\nWarning! The protocol described in this file is experimental an ackward incompatible changes may be made. Backward compatibl hanges may be added together with the corresponding interfac ersion bump.\nBackward incompatible changes are done by bumping the versio umber in the protocol and interface names and resetting th nterface version. Once the protocol is to be declared stable,\nthe 'z' prefix and the version number in the protocol an nterface names are removed and the interface version number i eset."
                },
                {
                    "title": "zwp_keyboard_shortcuts_inhibit_manager_v1",
                    "text": "A global interface used for inhibiting the compositor keyboard shortcuts."
                },
                {
                    "title": "zwp_keyboard_shortcuts_inhibitor_v1",
                    "text": "A keyboard shortcuts inhibitor instructs the compositor to ignor ts own keyboard shortcuts when the associated surface has keyboar ocus. As a result, when the surface has keyboard focus on the give eat, it will receive all key events originating from the specifie eat, even those which would normally be caught by the compositor fo ts own shortcuts.\n\nThe Wayland compositor is however under no obligation to disabl ll of its shortcuts, and may keep some special key combo for its ow se, including but not limited to one allowing the user to forcibl estore normal keyboard events routing in the case of an unwillin lient. The compositor may also use the same key combo to reactivat n existing shortcut inhibitor that was previously deactivated o ser request.\n\nWhen the compositor restores its own keyboard shortcuts, an\n\"inactive\" event is emitted to notify the client that the keyboar hortcuts inhibitor is not effectively active for the surface an eat any more, and the client should not expect to receive al eyboard events.\n\nWhen the keyboard shortcuts inhibitor is inactive, the client ha o way to forcibly reactivate the keyboard shortcuts inhibitor.\n\nThe user can chose to re-enable a previously deactivated keyboar hortcuts inhibitor using any mechanism the compositor may offer,\nin which case the compositor will send an \"active\" event to notif he client.\n\nIf the surface is destroyed, unmapped, or loses the seat's keyboar ocus, the keyboard shortcuts inhibitor becomes irrelevant and th ompositor will restore its own keyboard shortcuts but no \"inactive\"\nevent is emitted in this case."
                }
            ],
            "tags": {
                "source": "wayland",
                "stability": "unstable"
            },
            "source": "wayland-protocols",
            "supportIf": {
                "zwp_keyboard_shortcuts_inhibit_manager_v1": {
                    "mutter": 1,
                    "kwin": 1,
                    "sway": 1,
                    "cosmic": 1,
                    "hyprland": 1,
                    "niri": 1,
                    "wayfire": 1
                }
            },
            "supportSum": {
                "mutter": "full",
                "kwin": "full",
                "sway": "full",
                "cosmic": "full",
                "hyprland": "full",
                "niri": "full",
                "wayfire": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "linux-explicit-synchronization-unstable-v1",
            "name": "Linux explicit synchronization (dma-fence)",
            "descFull": [
                {
                    "title": "zwp_linux_explicit_synchronization_v1",
                    "text": "This global is a factory interface, allowing clients to reques xplicit synchronization for buffers on a per-surface basis.\n\nSee zwp_linux_surface_synchronization_v1 for more information.\n\nThis interface is derived from Chromium' cr_linux_explicit_synchronization_v1.\n\nNote: this protocol is superseded by linux-drm-syncobj.\n\nWarning! The protocol described in this file is experimental an ackward incompatible changes may be made. Backward compatible change ay be added together with the corresponding interface version bump.\nBackward incompatible changes are done by bumping the version number i he protocol and interface names and resetting the interface version.\nOnce the protocol is to be declared stable, the 'z' prefix and th ersion number in the protocol and interface names are removed and th nterface version number is reset."
                },
                {
                    "title": "zwp_linux_surface_synchronization_v1",
                    "text": "This object implements per-surface explicit synchronization.\n\nSynchronization refers to co-ordination of pipelined operations performe n buffers. Most GPU clients will schedule an asynchronous operation t ender to the buffer, then immediately send the buffer to the composito o be attached to a surface.\n\nIn implicit synchronization, ensuring that the rendering operation i omplete before the compositor displays the buffer is an implementatio etail handled by either the kernel or userspace graphics driver.\n\nBy contrast, in explicit synchronization, dma_fence objects mark when th synchronous operations are complete. When submitting a buffer, th lient provides an acquire fence which will be waited on before th ompositor accesses the buffer. The Wayland server, through  wp_linux_buffer_release_v1 object, will inform the client with an even hich may be accompanied by a release fence, when the compositor will n onger access the buffer contents due to the specific commit tha equested the release event.\n\nEach surface can be associated with only one object of this interface a ny time.\n\nIn version 1 of this interface, explicit synchronization is onl uaranteed to be supported for buffers created with any version of th p_linux_dmabuf buffer factory. Version 2 additionally guarantee xplicit synchronization support for opaque EGL buffers, which is a typ f platform specific buffers described in the EGL_WL_bind_wayland_displa xtension. Compositors are free to support explicit synchronization fo dditional buffer types."
                },
                {
                    "title": "zwp_linux_buffer_release_v1",
                    "text": "This object is instantiated in response to  wp_linux_surface_synchronization_v1.get_release request.\n\nIt provides an alternative to wl_buffer.release events, providing  nique release from a single wl_surface.commit request. The release even lso supports explicit synchronization, providing a fence FD for th lient to synchronize against.\n\nExactly one event, either a fenced_release or an immediate_release, wil e emitted for the wl_surface.commit request. The compositor can choos elease by release which event it uses.\n\nThis event does not replace wl_buffer.release events; servers are stil equired to send those events.\n\nOnce a buffer release object has delivered a 'fenced_release' or an\n'immediate_release' event it is automatically destroyed."
                }
            ],
            "tags": {
                "source": "wayland",
                "stability": "unstable",
                "deprecated": "deprecated"
            },
            "source": "wayland-protocols",
            "supportIf": {},
            "supportSum": {},
            "defaultExpand": false,
            "deprecations": {
                "zwp_linux_explicit_synchronization_v1": "Superseded by linux-drm-syncobj",
                "zwp_linux_surface_synchronization_v1": "Superseded by linux-drm-syncobj",
                "zwp_linux_buffer_release_v1": "Superseded by linux-drm-syncobj"
            },
            "deprecatedFull": true
        },
        {
            "id": "pointer-constraints-unstable-v1",
            "name": "Pointer constraints",
            "desc": "protocol for constraining pointer motions",
            "descFull": [
                {
                    "title": "Pointer constraints",
                    "text": "This protocol specifies a set of interfaces used for adding constraints t he motion of a pointer. Possible constraints include confining pointe otions to a given region, or locking it to its current position.\n\nIn order to constrain the pointer, a client must first bind the globa nterface \"wp_pointer_constraints\" which, if a compositor supports pointe onstraints, is exposed by the registry. Using the bound global object, th lient uses the request that corresponds to the type of constraint it want o make. See wp_pointer_constraints for more details.\n\nWarning! The protocol described in this file is experimental and backwar ncompatible changes may be made. Backward compatible changes may be adde ogether with the corresponding interface version bump. Backwar ncompatible changes are done by bumping the version number in the protoco nd interface names and resetting the interface version. Once the protoco s to be declared stable, the 'z' prefix and the version number in th rotocol and interface names are removed and the interface version number i eset."
                },
                {
                    "title": "zwp_pointer_constraints_v1",
                    "text": "The global interface exposing pointer constraining functionality. I xposes two requests: lock_pointer for locking the pointer to it osition, and confine_pointer for locking the pointer to a region.\n\nThe lock_pointer and confine_pointer requests create the object p_locked_pointer and wp_confined_pointer respectively, and the client ca se these objects to interact with the lock.\n\nFor any surface, only one lock or confinement may be active across al l_pointer objects of the same seat. If a lock or confinement is requeste hen another lock or confinement is active or requested on the same surfac nd with any of the wl_pointer objects of the same seat, an\n'already_constrained' error will be raised."
                },
                {
                    "title": "zwp_locked_pointer_v1",
                    "text": "The wp_locked_pointer interface represents a locked pointer state.\n\nWhile the lock of this object is active, the wl_pointer objects of th ssociated seat will not emit any wl_pointer.motion events.\n\nThis object will send the event 'locked' when the lock is activated.\nWhenever the lock is activated, it is guaranteed that the locked surfac ill already have received pointer focus and that the pointer will b ithin the region passed to the request creating this object.\n\nTo unlock the pointer, send the destroy request. This will also destro he wp_locked_pointer object.\n\nIf the compositor decides to unlock the pointer the unlocked event i ent. See wp_locked_pointer.unlock for details.\n\nWhen unlocking, the compositor may warp the cursor position to the se ursor position hint. If it does, it will not result in any relativ otion events emitted via wp_relative_pointer.\n\nIf the surface the lock was requested on is destroyed and the lock is no et activated, the wp_locked_pointer object is now defunct and must b estroyed."
                },
                {
                    "title": "zwp_confined_pointer_v1",
                    "text": "The wp_confined_pointer interface represents a confined pointer state.\n\nThis object will send the event 'confined' when the confinement i ctivated. Whenever the confinement is activated, it is guaranteed tha he surface the pointer is confined to will already have received pointe ocus and that the pointer will be within the region passed to the reques reating this object. It is up to the compositor to decide whether thi equires some user interaction and if the pointer will warp to within th assed region if outside.\n\nTo unconfine the pointer, send the destroy request. This will also destro he wp_confined_pointer object.\n\nIf the compositor decides to unconfine the pointer the unconfined event i ent. The wp_confined_pointer object is at this point defunct and shoul e destroyed."
                }
            ],
            "tags": {
                "source": "wayland",
                "stability": "unstable"
            },
            "source": "wayland-protocols",
            "supportIf": {
                "zwp_pointer_constraints_v1": {
                    "mutter": 1,
                    "kwin": 1,
                    "sway": 1,
                    "cosmic": 1,
                    "hyprland": 1,
                    "niri": 1,
                    "weston": 1,
                    "labwc": 1,
                    "wayfire": 1,
                    "gamescope": 1,
                    "jay": 1,
                    "mir": 1,
                    "louvre": 1
                }
            },
            "supportSum": {
                "mutter": "full",
                "kwin": "full",
                "sway": "full",
                "cosmic": "full",
                "hyprland": "full",
                "niri": "full",
                "weston": "full",
                "labwc": "full",
                "wayfire": "full",
                "gamescope": "full",
                "jay": "full",
                "mir": "full",
                "louvre": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "pointer-gestures-unstable-v1",
            "name": "Pointer gestures",
            "descFull": [
                {
                    "title": "zwp_pointer_gestures_v1",
                    "text": "A global interface to provide semantic touchpad gestures for a give ointer.\n\nThree gestures are currently supported: swipe, pinch, and hold.\nPinch and swipe gestures follow a three-stage cycle: begin, update,\nend. Hold gestures follow a two-stage cycle: begin and end. Al estures are identified by a unique id.\n\nWarning! The protocol described in this file is experimental an ackward incompatible changes may be made. Backward compatible change ay be added together with the corresponding interface version bump.\nBackward incompatible changes are done by bumping the version number i he protocol and interface names and resetting the interface version.\nOnce the protocol is to be declared stable, the 'z' prefix and th ersion number in the protocol and interface names are removed and th nterface version number is reset."
                },
                {
                    "title": "zwp_pointer_gesture_swipe_v1",
                    "text": "A swipe gesture object notifies a client about a multi-finger swip esture detected on an indirect input device such as a touchpad.\nThe gesture is usually initiated by multiple fingers moving in th ame direction but once initiated the direction may change.\nThe precise conditions of when such a gesture is detected ar mplementation-dependent.\n\nA gesture consists of three stages: begin, update (optional) and end.\nThere cannot be multiple simultaneous hold, pinch or swipe gestures on  ame pointer/seat, how compositors prevent these situations i mplementation-dependent.\n\nA gesture may be cancelled by the compositor or the hardware.\nClients should not consider performing permanent or irreversibl ctions until the end of a gesture has been received."
                },
                {
                    "title": "zwp_pointer_gesture_pinch_v1",
                    "text": "A pinch gesture object notifies a client about a multi-finger pinc esture detected on an indirect input device such as a touchpad.\nThe gesture is usually initiated by multiple fingers moving toward ach other or away from each other, or by two or more fingers rotatin round a logical center of gravity. The precise conditions of whe uch a gesture is detected are implementation-dependent.\n\nA gesture consists of three stages: begin, update (optional) and end.\nThere cannot be multiple simultaneous hold, pinch or swipe gestures on  ame pointer/seat, how compositors prevent these situations i mplementation-dependent.\n\nA gesture may be cancelled by the compositor or the hardware.\nClients should not consider performing permanent or irreversibl ctions until the end of a gesture has been received."
                },
                {
                    "title": "zwp_pointer_gesture_hold_v1",
                    "text": "A hold gesture object notifies a client about a single- o ulti-finger hold gesture detected on an indirect input device such a  touchpad. The gesture is usually initiated by one or more finger eing held down without significant movement. The precise condition f when such a gesture is detected are implementation-dependent.\n\nIn particular, this gesture may be used to cancel kinetic scrolling.\n\nA hold gesture consists of two stages: begin and end. Unlike pinch an wipe there is no update stage.\nThere cannot be multiple simultaneous hold, pinch or swipe gestures on  ame pointer/seat, how compositors prevent these situations i mplementation-dependent.\n\nA gesture may be cancelled by the compositor or the hardware.\nClients should not consider performing permanent or irreversibl ctions until the end of a gesture has been received."
                }
            ],
            "tags": {
                "source": "wayland",
                "stability": "unstable"
            },
            "source": "wayland-protocols",
            "supportIf": {
                "zwp_pointer_gestures_v1": {
                    "mutter": 1,
                    "kwin": 1,
                    "sway": 1,
                    "cosmic": 1,
                    "hyprland": 1,
                    "niri": 1,
                    "labwc": 1,
                    "wayfire": 1,
                    "jay": 1,
                    "treeland": 1,
                    "louvre": 1
                }
            },
            "supportSum": {
                "mutter": "full",
                "kwin": "full",
                "sway": "full",
                "cosmic": "full",
                "hyprland": "full",
                "niri": "full",
                "labwc": "full",
                "wayfire": "full",
                "jay": "full",
                "treeland": "full",
                "louvre": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "primary-selection-unstable-v1",
            "name": "Primary selection",
            "desc": "Primary selection protocol",
            "descFull": [
                {
                    "title": "Primary selection",
                    "text": "This protocol provides the ability to have a primary selection device t atch that of the X server. This primary selection is a shortcut to th ommon clipboard selection, where text just needs to be selected in orde o allow copying it elsewhere. The de facto way to perform this actio s the middle mouse button, although it is not limited to this one.\n\nClients wishing to honor primary selection should create a primar election source and set it as the selection throug p_primary_selection_device.set_selection whenever the text selectio hanges. In order to minimize calls in pointer-driven text selection,\nit should happen only once after the operation finished. Similarly,\na NULL source should be set when text is unselected.\n\nwp_primary_selection_offer objects are first announced through th p_primary_selection_device.data_offer event. Immediately after this event,\nthe primary data offer will emit wp_primary_selection_offer.offer event o let know of the mime types being offered.\n\nWhen the primary selection changes, the client with the keyboard focu ill receive wp_primary_selection_device.selection events. Only the clien ith the keyboard focus will receive such events with a non-NUL p_primary_selection_offer. Across keyboard focus changes, previousl ocused clients will receive wp_primary_selection_device.events with  ULL wp_primary_selection_offer.\n\nIn order to request the primary selection data, the client must pas  recent serial pertaining to the press event that is triggering th peration, if the compositor deems the serial valid and recent, th p_primary_selection_source.send event will happen in the other en o let the transfer begin. The client owning the primary selectio hould write the requested data, and close the file descripto mmediately.\n\nIf the primary selection owner client disappeared during the transfer,\nthe client reading the data will receive  p_primary_selection_device.selection event with a NUL p_primary_selection_offer, the client should take this as a hin o finish the reads related to the no longer existing offer.\n\nThe primary selection owner should be checking for errors durin rites, merely cancelling the ongoing transfer if any happened."
                },
                {
                    "title": "zwp_primary_selection_device_manager_v1",
                    "text": "The primary selection device manager is a singleton global object tha rovides access to the primary selection. It allows to creat p_primary_selection_source objects, as well as retrieving the per-sea p_primary_selection_device objects."
                },
                {
                    "title": "zwp_primary_selection_offer_v1",
                    "text": "A wp_primary_selection_offer represents an offer to transfer the content f the primary selection clipboard to the client. Similar t l_data_offer, the offer also describes the mime types that the data ca e converted to and provides the mechanisms for transferring the dat irectly to the client."
                },
                {
                    "title": "zwp_primary_selection_source_v1",
                    "text": "The source side of a wp_primary_selection_offer, it provides a way t escribe the offered data and respond to requests to transfer th equested contents of the primary selection clipboard."
                }
            ],
            "tags": {
                "source": "wayland",
                "stability": "unstable"
            },
            "source": "wayland-protocols",
            "supportIf": {
                "zwp_primary_selection_device_manager_v1": {
                    "mutter": 1,
                    "kwin": 1,
                    "sway": 1,
                    "cosmic": 1,
                    "hyprland": 1,
                    "niri": 1,
                    "labwc": 1,
                    "cage": 1,
                    "wayfire": 1,
                    "jay": 1,
                    "mir": 1,
                    "treeland": 1
                }
            },
            "supportSum": {
                "mutter": "full",
                "kwin": "full",
                "sway": "full",
                "cosmic": "full",
                "hyprland": "full",
                "niri": "full",
                "labwc": "full",
                "cage": "full",
                "wayfire": "full",
                "jay": "full",
                "mir": "full",
                "treeland": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "relative-pointer-unstable-v1",
            "name": "Relative pointer",
            "desc": "protocol for relative pointer motion events",
            "descFull": [
                {
                    "title": "Relative pointer",
                    "text": "This protocol specifies a set of interfaces used for making clients able t eceive relative pointer events not obstructed by barriers (such as th onitor edge or other pointer barriers).\n\nTo start receiving relative pointer events, a client must first bind th lobal interface \"wp_relative_pointer_manager\" which, if a composito upports relative pointer motion events, is exposed by the registry. Afte aving created the relative pointer manager proxy object, the client use t to create the actual relative pointer object using the\n\"get_relative_pointer\" request given a wl_pointer. The relative pointe otion events will then, when applicable, be transmitted via the proxy o he newly created relative pointer object. See the documentation of th elative pointer interface for more details.\n\nWarning! The protocol described in this file is experimental and backwar ncompatible changes may be made. Backward compatible changes may be adde ogether with the corresponding interface version bump. Backwar ncompatible changes are done by bumping the version number in the protoco nd interface names and resetting the interface version. Once the protoco s to be declared stable, the 'z' prefix and the version number in th rotocol and interface names are removed and the interface version number i eset."
                },
                {
                    "title": "zwp_relative_pointer_manager_v1",
                    "text": "A global interface used for getting the relative pointer object for  iven pointer."
                },
                {
                    "title": "zwp_relative_pointer_v1",
                    "text": "A wp_relative_pointer object is an extension to the wl_pointer interfac sed for emitting relative pointer events. It shares the same focus a l_pointer objects of the same seat and will only emit events when it ha ocus."
                }
            ],
            "tags": {
                "source": "wayland",
                "stability": "unstable"
            },
            "source": "wayland-protocols",
            "supportIf": {
                "zwp_relative_pointer_manager_v1": {
                    "mutter": 1,
                    "kwin": 1,
                    "sway": 1,
                    "cosmic": 1,
                    "hyprland": 1,
                    "niri": 1,
                    "weston": 1,
                    "labwc": 1,
                    "cage": 1,
                    "wayfire": 1,
                    "gamescope": 1,
                    "jay": 1,
                    "mir": 1,
                    "louvre": 1
                }
            },
            "supportSum": {
                "mutter": "full",
                "kwin": "full",
                "sway": "full",
                "cosmic": "full",
                "hyprland": "full",
                "niri": "full",
                "weston": "full",
                "labwc": "full",
                "cage": "full",
                "wayfire": "full",
                "gamescope": "full",
                "jay": "full",
                "mir": "full",
                "louvre": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "text-input-unstable-v3",
            "name": "Text input",
            "desc": "Protocol for composing text",
            "descFull": [
                {
                    "title": "Text input",
                    "text": "This protocol allows compositors to act as input methods and to send tex o applications. A text input object is used to manage state of what ar ypically text entry fields in the application.\n\nThis document adheres to the RFC 2119 when using words like \"must\",\n\"should\", \"may\", etc.\n\nWarning! The protocol described in this file is experimental an ackward incompatible changes may be made. Backward compatible change ay be added together with the corresponding interface version bump.\nBackward incompatible changes are done by bumping the version number i he protocol and interface names and resetting the interface version.\nOnce the protocol is to be declared stable, the 'z' prefix and th ersion number in the protocol and interface names are removed and th nterface version number is reset."
                },
                {
                    "title": "zwp_text_input_v3",
                    "text": "The zwp_text_input_v3 interface represents text input and input method ssociated with a seat. It provides enter/leave events to follow th ext input focus for a seat.\n\nRequests are used to enable/disable the text-input object and se tate information like surrounding and selected text or the content type.\nThe information about the entered text is sent to the text-input objec ia the preedit_string and commit_string events.\n\nText is valid UTF-8 encoded, indices and lengths are in bytes. Indice ust not point to middle bytes inside a code point: they must eithe oint to the first byte of a code point or to the end of the buffer.\nLengths must be measured between two valid indices.\n\nFocus moving throughout surfaces will result in the emission o wp_text_input_v3.enter and zwp_text_input_v3.leave events. The focuse urface must commit zwp_text_input_v3.enable an wp_text_input_v3.disable requests as the keyboard focus moves acros ditable and non-editable elements of the UI. Those two requests are no xpected to be paired with each other, the compositor must be able t andle consecutive series of the same request.\n\nState is sent by the state requests (set_surrounding_text,\nset_content_type and set_cursor_rectangle) and a commit request. After a nter event or disable request all state information is invalidated an eeds to be resent by the client."
                },
                {
                    "title": "zwp_text_input_manager_v3",
                    "text": "A factory for text-input objects. This object is a global singleton."
                }
            ],
            "tags": {
                "source": "wayland",
                "stability": "unstable"
            },
            "source": "wayland-protocols",
            "supportIf": {
                "zwp_text_input_manager_v3": {
                    "mutter": 1,
                    "kwin": 1,
                    "sway": 1,
                    "cosmic": 1,
                    "hyprland": 1,
                    "niri": 1,
                    "labwc": 1,
                    "jay": 1,
                    "mir": 1,
                    "treeland": 1
                }
            },
            "supportSum": {
                "mutter": "full",
                "kwin": "full",
                "sway": "full",
                "cosmic": "full",
                "hyprland": "full",
                "niri": "full",
                "labwc": "full",
                "jay": "full",
                "mir": "full",
                "treeland": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "xdg-decoration-unstable-v1",
            "name": "XDG decoration",
            "descFull": [
                {
                    "title": "zxdg_decoration_manager_v1",
                    "text": "This interface allows a compositor to announce support for server-sid ecorations.\n\nA window decoration is a set of window controls as deemed appropriate b he party managing them, such as user interface components used to move,\nresize and change a window's state.\n\nA client can use this protocol to request being decorated by a supportin ompositor.\n\nIf compositor and client do not negotiate the use of a server-sid ecoration using this protocol, clients continue to self-decorate as the ee fit.\n\nWarning! The protocol described in this file is experimental an ackward incompatible changes may be made. Backward compatible change ay be added together with the corresponding interface version bump.\nBackward incompatible changes are done by bumping the version number i he protocol and interface names and resetting the interface version.\nOnce the protocol is to be declared stable, the 'z' prefix and th ersion number in the protocol and interface names are removed and th nterface version number is reset."
                },
                {
                    "title": "zxdg_toplevel_decoration_v1",
                    "text": "The decoration object allows the compositor to toggle server-side windo ecorations for a toplevel surface. The client can request to switch t nother mode.\n\nThe xdg_toplevel_decoration object must be destroyed before it dg_toplevel."
                }
            ],
            "tags": {
                "source": "wayland",
                "stability": "unstable"
            },
            "source": "wayland-protocols",
            "supportIf": {
                "zxdg_decoration_manager_v1": {
                    "kwin": 1,
                    "sway": 1,
                    "cosmic": 1,
                    "hyprland": 1,
                    "niri": 1,
                    "labwc": 1,
                    "cage": 1,
                    "wayfire": 1,
                    "jay": 1,
                    "mir": 1,
                    "treeland": 1,
                    "louvre": 1
                }
            },
            "supportSum": {
                "kwin": "full",
                "sway": "full",
                "cosmic": "full",
                "hyprland": "full",
                "niri": "full",
                "labwc": "full",
                "cage": "full",
                "wayfire": "full",
                "jay": "full",
                "mir": "full",
                "treeland": "full",
                "louvre": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "xdg-foreign-unstable-v2",
            "name": "XDG foreign",
            "desc": "Protocol for exporting xdg surface handles",
            "descFull": [
                {
                    "title": "XDG foreign",
                    "text": "This protocol specifies a way for making it possible to reference a surfac f a different client. With such a reference, a client can, by using th nterfaces provided by this protocol, manipulate the relationship betwee ts own surfaces and the surface of some other client. For example, stac ome of its own surface above the other clients surface.\n\nIn order for a client A to get a reference of a surface of client B, clien  must first export its surface using xdg_exporter.export_toplevel. Upo oing this, client B will receive a handle (a unique string) that it ma hare with client A in some way (for example D-Bus). After client A ha eceived the handle from client B, it may use xdg_importer.import_topleve o create a reference to the surface client B just exported. See th orresponding requests for details.\n\nA possible use case for this is out-of-process dialogs. For example when  andboxed client without file system access needs the user to select a fil n the file system, given sandbox environment support, it can export it urface, passing the exported surface handle to an unsandboxed process tha an show a file browser dialog and stack it above the sandboxed client' urface.\n\nWarning! The protocol described in this file is experimental and backwar ncompatible changes may be made. Backward compatible changes may be adde ogether with the corresponding interface version bump. Backwar ncompatible changes are done by bumping the version number in the protoco nd interface names and resetting the interface version. Once the protoco s to be declared stable, the 'z' prefix and the version number in th rotocol and interface names are removed and the interface version number i eset."
                },
                {
                    "title": "zxdg_exporter_v2",
                    "text": "A global interface used for exporting surfaces that can later be importe sing xdg_importer."
                },
                {
                    "title": "zxdg_importer_v2",
                    "text": "A global interface used for importing surfaces exported by xdg_exporter.\nWith this interface, a client can create a reference to a surface o nother client."
                },
                {
                    "title": "zxdg_exported_v2",
                    "text": "An xdg_exported object represents an exported reference to a surface. Th xported surface may be referenced as long as the xdg_exported object no estroyed. Destroying the xdg_exported invalidates any relationship th mporter may have established using xdg_imported."
                },
                {
                    "title": "zxdg_imported_v2",
                    "text": "An xdg_imported object represents an imported reference to surface exporte y some client. A client can use this interface to manipulat elationships between its own surfaces and the imported surface."
                }
            ],
            "tags": {
                "source": "wayland",
                "stability": "unstable"
            },
            "source": "wayland-protocols",
            "supportIf": {
                "zxdg_exporter_v2": {
                    "mutter": 1,
                    "kwin": 1,
                    "sway": 1,
                    "cosmic": 1,
                    "niri": 1,
                    "labwc": 1,
                    "wayfire": 1
                },
                "zxdg_importer_v2": {
                    "mutter": 1,
                    "kwin": 1,
                    "sway": 1,
                    "cosmic": 1,
                    "niri": 1,
                    "labwc": 1,
                    "wayfire": 1
                }
            },
            "supportSum": {
                "mutter": "full",
                "kwin": "full",
                "sway": "full",
                "cosmic": "full",
                "niri": "full",
                "labwc": "full",
                "wayfire": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "xdg-output-unstable-v1",
            "name": "XDG output",
            "desc": "Protocol to describe output regions",
            "descFull": [
                {
                    "title": "XDG output",
                    "text": "This protocol aims at describing outputs in a way which is more in lin ith the concept of an output on desktop oriented systems.\n\nSome information are more specific to the concept of an output fo  desktop oriented system and may not make sense in other applications,\nsuch as IVI systems for example.\n\nTypically, the global compositor space on a desktop system is made o  contiguous or overlapping set of rectangular regions.\n\nThe logical_position and logical_size events defined in this protoco ight provide information identical to their counterparts alread vailable from wl_output, in which case the information provided by thi rotocol should be preferred to their equivalent in wl_output. The goal i o move the desktop specific concepts (such as output location within th lobal compositor space, etc.) out of the core wl_output protocol.\n\nWarning! The protocol described in this file is experimental an ackward incompatible changes may be made. Backward compatibl hanges may be added together with the corresponding interfac ersion bump.\nBackward incompatible changes are done by bumping the versio umber in the protocol and interface names and resetting th nterface version. Once the protocol is to be declared stable,\nthe 'z' prefix and the version number in the protocol an nterface names are removed and the interface version number i eset."
                },
                {
                    "title": "zxdg_output_manager_v1",
                    "text": "A global factory interface for xdg_output objects."
                },
                {
                    "title": "zxdg_output_v1",
                    "text": "An xdg_output describes part of the compositor geometry.\n\nThis typically corresponds to a monitor that displays part of th ompositor space.\n\nFor objects version 3 onwards, after all xdg_output properties have bee ent (when the object is created and when properties are updated),  l_output.done event is sent. This allows changes to the outpu roperties to be seen as atomic, even if they happen via multiple events."
                }
            ],
            "tags": {
                "source": "wayland",
                "stability": "unstable"
            },
            "source": "wayland-protocols",
            "supportIf": {
                "zxdg_output_manager_v1": {
                    "mutter": 1,
                    "kwin": 1,
                    "sway": 1,
                    "cosmic": 1,
                    "hyprland": 1,
                    "niri": 1,
                    "weston": 1,
                    "labwc": 1,
                    "cage": 1,
                    "wayfire": 1,
                    "jay": 1,
                    "mir": 1,
                    "treeland": 1,
                    "louvre": 1
                }
            },
            "supportSum": {
                "mutter": "full",
                "kwin": "full",
                "sway": "full",
                "cosmic": "full",
                "hyprland": "full",
                "niri": "full",
                "weston": "full",
                "labwc": "full",
                "cage": "full",
                "wayfire": "full",
                "jay": "full",
                "mir": "full",
                "treeland": "full",
                "louvre": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "xwayland-keyboard-grab-unstable-v1",
            "name": "XWayland keyboard grabbing",
            "desc": "Protocol for grabbing the keyboard from Xwayland",
            "descFull": [
                {
                    "title": "XWayland keyboard grabbing",
                    "text": "This protocol is application-specific to meet the needs of the X1 rotocol through Xwayland. It provides a way for Xwayland to reques ll keyboard events to be forwarded to a surface even when th urface does not have keyboard focus.\n\nIn the X11 protocol, a client may request an \"active grab\" on th eyboard. On success, all key events are reported only to th rabbing X11 client. For details, see XGrabKeyboard(3).\n\nThe core Wayland protocol does not have a notion of an activ eyboard grab. When running in Xwayland, X11 applications ma cquire an active grab inside Xwayland but that cannot be translate o the Wayland compositor who may set the input focus to some othe urface. In doing so, it breaks the X11 client assumption that al ey events are reported to the grabbing client.\n\nThis protocol specifies a way for Xwayland to request all keyboar e directed to the given surface. The protocol does not guarante hat the compositor will honor this request and it does no rescribe user interfaces on how to handle the respond. For example,\na compositor may inform the user that all key events are no orwarded to the given client surface, or it may ask the user fo ermission to do so.\n\nCompositors are required to restrict access to this applicatio pecific protocol to Xwayland alone.\n\nWarning! The protocol described in this file is experimental an ackward incompatible changes may be made. Backward compatibl hanges may be added together with the corresponding interfac ersion bump.\nBackward incompatible changes are done by bumping the versio umber in the protocol and interface names and resetting th nterface version. Once the protocol is to be declared stable,\nthe 'z' prefix and the version number in the protocol an nterface names are removed and the interface version number i eset."
                },
                {
                    "title": "zwp_xwayland_keyboard_grab_manager_v1",
                    "text": "A global interface used for grabbing the keyboard."
                },
                {
                    "title": "zwp_xwayland_keyboard_grab_v1",
                    "text": "A global interface used for grabbing the keyboard."
                }
            ],
            "tags": {
                "source": "wayland",
                "stability": "unstable"
            },
            "source": "wayland-protocols",
            "supportIf": {},
            "supportSum": {},
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "wlr-data-control-unstable-v1",
            "name": "wlr data control",
            "desc": "control data devices",
            "descFull": [
                {
                    "title": "wlr data control",
                    "text": "This protocol allows a privileged client to control data devices. I articular, the client will be able to manage the current selection and tak he role of a clipboard manager.\n\nWarning! The protocol described in this file is experimental an ackward incompatible changes may be made. Backward compatible change ay be added together with the corresponding interface version bump.\nBackward incompatible changes are done by bumping the version number i he protocol and interface names and resetting the interface version.\nOnce the protocol is to be declared stable, the 'z' prefix and th ersion number in the protocol and interface names are removed and th nterface version number is reset."
                },
                {
                    "title": "zwlr_data_control_manager_v1",
                    "text": "This interface is a manager that allows creating per-seat data devic ontrols."
                },
                {
                    "title": "zwlr_data_control_device_v1",
                    "text": "This interface allows a client to manage a seat's selection.\n\nWhen the seat is destroyed, this object becomes inert."
                },
                {
                    "title": "zwlr_data_control_source_v1",
                    "text": "The wlr_data_control_source object is the source side of  lr_data_control_offer. It is created by the source client in a dat ransfer and provides a way to describe the offered data and a way t espond to requests to transfer the data."
                },
                {
                    "title": "zwlr_data_control_offer_v1",
                    "text": "A wlr_data_control_offer represents a piece of data offered for transfe y another client (the source client). The offer describes the differen IME types that the data can be converted to and provides the mechanis or transferring the data directly from the source client."
                }
            ],
            "tags": {
                "source": "wlr",
                "stability": "unstable"
            },
            "source": "wlr-protocols",
            "supportIf": {
                "zwlr_data_control_manager_v1": {
                    "kwin": 1,
                    "sway": 1,
                    "cosmic": 1,
                    "hyprland": 1,
                    "niri": 1,
                    "labwc": 1,
                    "wayfire": 1,
                    "jay": 1,
                    "treeland": 1
                }
            },
            "supportSum": {
                "kwin": "full",
                "sway": "full",
                "cosmic": "full",
                "hyprland": "full",
                "niri": "full",
                "labwc": "full",
                "wayfire": "full",
                "jay": "full",
                "treeland": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "wlr-export-dmabuf-unstable-v1",
            "name": "wlr export DMA-BUF",
            "desc": "a protocol for low overhead screen content capturing",
            "descFull": [
                {
                    "title": "wlr export DMA-BUF",
                    "text": "An interface to capture surfaces in an efficient way by exporting DMA-BUFs.\n\nWarning! The protocol described in this file is experimental an ackward incompatible changes may be made. Backward compatible change ay be added together with the corresponding interface version bump.\nBackward incompatible changes are done by bumping the version number i he protocol and interface names and resetting the interface version.\nOnce the protocol is to be declared stable, the 'z' prefix and th ersion number in the protocol and interface names are removed and th nterface version number is reset."
                },
                {
                    "title": "zwlr_export_dmabuf_manager_v1",
                    "text": "This object is a manager with which to start capturing from sources."
                },
                {
                    "title": "zwlr_export_dmabuf_frame_v1",
                    "text": "This object represents a single DMA-BUF frame.\n\nIf the capture is successful, the compositor will first send a \"frame\"\nevent, followed by one or several \"object\". When the frame is availabl or readout, the \"ready\" event is sent.\n\nIf the capture failed, the \"cancel\" event is sent. This can happen anytim efore the \"ready\" event.\n\nOnce either a \"ready\" or a \"cancel\" event is received, the client shoul estroy the frame. Once an \"object\" event is received, the client i esponsible for closing the associated file descriptor.\n\nAll frames are read-only and may not be written into or altered."
                }
            ],
            "tags": {
                "source": "wlr",
                "stability": "unstable"
            },
            "source": "wlr-protocols",
            "supportIf": {
                "zwlr_export_dmabuf_manager_v1": {
                    "sway": 1,
                    "labwc": 1,
                    "cage": 1,
                    "wayfire": 1
                }
            },
            "supportSum": {
                "sway": "full",
                "labwc": "full",
                "cage": "full",
                "wayfire": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "wlr-foreign-toplevel-management-unstable-v1",
            "name": "wlr foreign toplevel management",
            "descFull": [
                {
                    "title": "zwlr_foreign_toplevel_manager_v1",
                    "text": "The purpose of this protocol is to enable the creation of taskbar nd docks by providing them with a list of opened applications an etting them request certain actions on them, like maximizing, etc.\n\nAfter a client binds the zwlr_foreign_toplevel_manager_v1, each opene oplevel window will be sent via the toplevel event"
                },
                {
                    "title": "zwlr_foreign_toplevel_handle_v1",
                    "text": "A zwlr_foreign_toplevel_handle_v1 object represents an opened topleve indow. Each app may have multiple opened toplevels.\n\nEach toplevel has a list of outputs it is visible on, conveyed to th lient with the output_enter and output_leave events."
                }
            ],
            "tags": {
                "source": "wlr",
                "stability": "unstable"
            },
            "source": "wlr-protocols",
            "supportIf": {
                "zwlr_foreign_toplevel_manager_v1": {
                    "sway": 1,
                    "hyprland": 1,
                    "niri": 1,
                    "labwc": 1,
                    "wayfire": 1,
                    "mir": 1,
                    "treeland": 1,
                    "louvre": 1
                }
            },
            "supportSum": {
                "sway": "full",
                "hyprland": "full",
                "niri": "full",
                "labwc": "full",
                "wayfire": "full",
                "mir": "full",
                "treeland": "full",
                "louvre": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "wlr-gamma-control-unstable-v1",
            "name": "wlr gamma control",
            "desc": "manage gamma tables of outputs",
            "descFull": [
                {
                    "title": "wlr gamma control",
                    "text": "This protocol allows a privileged client to set the gamma tables fo utputs.\n\nWarning! The protocol described in this file is experimental an ackward incompatible changes may be made. Backward compatible change ay be added together with the corresponding interface version bump.\nBackward incompatible changes are done by bumping the version number i he protocol and interface names and resetting the interface version.\nOnce the protocol is to be declared stable, the 'z' prefix and th ersion number in the protocol and interface names are removed and th nterface version number is reset."
                },
                {
                    "title": "zwlr_gamma_control_manager_v1",
                    "text": "This interface is a manager that allows creating per-output gamm ontrols."
                },
                {
                    "title": "zwlr_gamma_control_v1",
                    "text": "This interface allows a client to adjust gamma tables for a particula utput.\n\nThe client will receive the gamma size, and will then be able to set gamm ables. At any time the compositor can send a failed event indicating tha his object is no longer valid.\n\nThere can only be at most one gamma control object per output, whic as exclusive access to this particular output. When the gamma contro bject is destroyed, the gamma table is restored to its original value."
                }
            ],
            "tags": {
                "source": "wlr",
                "stability": "unstable"
            },
            "source": "wlr-protocols",
            "supportIf": {
                "zwlr_gamma_control_manager_v1": {
                    "sway": 1,
                    "hyprland": 1,
                    "niri": 1,
                    "labwc": 1,
                    "cage": 1,
                    "wayfire": 1,
                    "treeland": 1,
                    "louvre": 1
                }
            },
            "supportSum": {
                "sway": "full",
                "hyprland": "full",
                "niri": "full",
                "labwc": "full",
                "cage": "full",
                "wayfire": "full",
                "treeland": "full",
                "louvre": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "wlr-input-inhibitor-unstable-v1",
            "name": "wlr input inhibitor",
            "descFull": [
                {
                    "title": "zwlr_input_inhibit_manager_v1",
                    "text": "Clients can use this interface to prevent input events from being sent t ny surfaces but its own, which is useful for example in lock scree oftware. It is assumed that access to this interface will be locked dow o whitelisted clients by the compositor.\n\nNote! This protocol is deprecated and not intended for production use.\nFor screen lockers, use the ext-session-lock-v1 protocol."
                },
                {
                    "title": "zwlr_input_inhibitor_v1",
                    "text": "While this resource exists, input to clients other than the owner of th nhibitor resource will not receive input events. Any client whic reviously had focus will receive a leave event and will not be give ocus again. The client that owns this resource will receive all inpu vents normally. The compositor will also disable all of its own inpu rocessing (such as keyboard shortcuts) while the inhibitor is active.\n\nThe compositor may continue to send input events to selected clients,\nsuch as an on-screen keyboard (via the input-method protocol)."
                }
            ],
            "tags": {
                "source": "wlr",
                "stability": "unstable"
            },
            "source": "wlr-protocols",
            "supportIf": {},
            "supportSum": {},
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "wlr-layer-shell-unstable-v1",
            "name": "wlr layer shell",
            "descFull": [
                {
                    "title": "zwlr_layer_shell_v1",
                    "text": "Clients can use this interface to assign the surface_layer role t l_surfaces. Such surfaces are assigned to a \"layer\" of the output an endered with a defined z-depth respective to each other. They may also b nchored to the edges and corners of a screen and specify input handlin emantics. This interface should be suitable for the implementation o any desktop shell components, and a broad number of other application hat interact with the desktop."
                },
                {
                    "title": "zwlr_layer_surface_v1",
                    "text": "An interface that may be implemented by a wl_surface, for surfaces tha re designed to be rendered as a layer of a stacked desktop-lik nvironment.\n\nLayer surface state (layer, size, anchor, exclusive zone,\nmargin, interactivity) is double-buffered, and will be applied at th ime wl_surface.commit of the corresponding wl_surface is called.\n\nAttaching a null buffer to a layer surface unmaps it.\n\nUnmapping a layer_surface means that the surface cannot be shown by th ompositor until it is explicitly mapped again. The layer_surfac eturns to the state it had right after layer_shell.get_layer_surface.\nThe client can re-map the surface by performing a commit without an uffer attached, waiting for a configure event and handling it as usual."
                }
            ],
            "tags": {
                "source": "wlr",
                "stability": "unstable"
            },
            "source": "wlr-protocols",
            "supportIf": {
                "zwlr_layer_shell_v1": {
                    "kwin": 1,
                    "sway": 1,
                    "cosmic": 1,
                    "hyprland": 1,
                    "niri": 1,
                    "labwc": 1,
                    "wayfire": 1,
                    "gamescope": 1,
                    "jay": 1,
                    "mir": 1,
                    "treeland": 1,
                    "louvre": 1
                }
            },
            "supportSum": {
                "kwin": "full",
                "sway": "full",
                "cosmic": "full",
                "hyprland": "full",
                "niri": "full",
                "labwc": "full",
                "wayfire": "full",
                "gamescope": "full",
                "jay": "full",
                "mir": "full",
                "treeland": "full",
                "louvre": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "wlr-output-management-unstable-v1",
            "name": "wlr output management",
            "desc": "protocol to configure output devices",
            "descFull": [
                {
                    "title": "wlr output management",
                    "text": "This protocol exposes interfaces to obtain and modify output devic onfiguration.\n\nWarning! The protocol described in this file is experimental an ackward incompatible changes may be made. Backward compatible change ay be added together with the corresponding interface version bump.\nBackward incompatible changes are done by bumping the version number i he protocol and interface names and resetting the interface version.\nOnce the protocol is to be declared stable, the 'z' prefix and th ersion number in the protocol and interface names are removed and th nterface version number is reset."
                },
                {
                    "title": "zwlr_output_manager_v1",
                    "text": "This interface is a manager that allows reading and writing the curren utput device configuration.\n\nOutput devices that display pixels (e.g. a physical monitor or a virtua utput in a window) are represented as heads. Heads cannot be created no estroyed by the client, but they can be enabled or disabled and thei roperties can be changed. Each head may have one or more available modes.\n\nWhenever a head appears (e.g. a monitor is plugged in), it will b dvertised via the head event. Immediately after the output manager i ound, all current heads are advertised.\n\nWhenever a head's properties change, the relevant wlr_output_head event ill be sent. Not all head properties will be sent: only properties tha ave changed need to.\n\nWhenever a head disappears (e.g. a monitor is unplugged),  lr_output_head.finished event will be sent.\n\nAfter one or more heads appear, change or disappear, the done event wil e sent. It carries a serial which can be used in a create_configuratio equest to update heads properties.\n\nThe information obtained from this protocol should only be used for outpu onfiguration purposes. This protocol is not designed to be a generi utput property advertisement protocol for regular clients. Instead,\nprotocols such as xdg-output should be used."
                },
                {
                    "title": "zwlr_output_head_v1",
                    "text": "A head is an output device. The difference between a wl_output object an  head is that heads are advertised even if they are turned off. A hea bject only advertises properties and cannot be used directly to chang hem.\n\nA head has some read-only properties: modes, name, description an hysical_size. These cannot be changed by clients.\n\nOther properties can be updated via a wlr_output_configuration object.\n\nProperties sent via this interface are applied atomically via th lr_output_manager.done event. No guarantees are made regarding the orde n which properties are sent."
                },
                {
                    "title": "zwlr_output_mode_v1",
                    "text": "This object describes an output mode.\n\nSome heads don't support output modes, in which case modes won't b dvertised.\n\nProperties sent via this interface are applied atomically via th lr_output_manager.done event. No guarantees are made regarding the orde n which properties are sent."
                },
                {
                    "title": "zwlr_output_configuration_v1",
                    "text": "This object is used by the client to describe a full output configuration.\n\nFirst, the client needs to setup the output configuration. Each head ca e either enabled (and configured) or disabled. It is a protocol error t end two enable_head or disable_head requests with the same head. It is  rotocol error to omit a head in a configuration.\n\nThen, the client can apply or test the configuration. The compositor wil hen reply with a succeeded, failed or cancelled event. Finally the clien hould destroy the configuration object."
                },
                {
                    "title": "zwlr_output_configuration_head_v1",
                    "text": "This object is used by the client to update a single head's configuration.\n\nIt is a protocol error to set the same property twice."
                }
            ],
            "tags": {
                "source": "wlr",
                "stability": "unstable"
            },
            "source": "wlr-protocols",
            "supportIf": {
                "zwlr_output_manager_v1": {
                    "sway": 1,
                    "cosmic": 1,
                    "hyprland": 1,
                    "niri": 1,
                    "labwc": 1,
                    "cage": 1,
                    "wayfire": 1,
                    "treeland": 1,
                    "louvre": 1
                }
            },
            "supportSum": {
                "sway": "full",
                "cosmic": "full",
                "hyprland": "full",
                "niri": "full",
                "labwc": "full",
                "cage": "full",
                "wayfire": "full",
                "treeland": "full",
                "louvre": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "wlr-output-power-management-unstable-v1",
            "name": "wlr output power management",
            "desc": "Control power management modes of outputs",
            "descFull": [
                {
                    "title": "wlr output power management",
                    "text": "This protocol allows clients to control power management mode f outputs that are currently part of the compositor space. Th ntent is to allow special clients like desktop shells to powe own outputs when the system is idle.\n\nTo modify outputs not currently part of the compositor space se lr-output-management.\n\nWarning! The protocol described in this file is experimental an ackward incompatible changes may be made. Backward compatible change ay be added together with the corresponding interface version bump.\nBackward incompatible changes are done by bumping the version number i he protocol and interface names and resetting the interface version.\nOnce the protocol is to be declared stable, the 'z' prefix and th ersion number in the protocol and interface names are removed and th nterface version number is reset."
                },
                {
                    "title": "zwlr_output_power_manager_v1",
                    "text": "This interface is a manager that allows creating per-output powe anagement mode controls."
                },
                {
                    "title": "zwlr_output_power_v1",
                    "text": "This object offers requests to set the power management mode o n output."
                }
            ],
            "tags": {
                "source": "wlr",
                "stability": "unstable"
            },
            "source": "wlr-protocols",
            "supportIf": {
                "zwlr_output_power_manager_v1": {
                    "sway": 1,
                    "cosmic": 1,
                    "hyprland": 1,
                    "labwc": 1,
                    "wayfire": 1,
                    "treeland": 1
                }
            },
            "supportSum": {
                "sway": "full",
                "cosmic": "full",
                "hyprland": "full",
                "labwc": "full",
                "wayfire": "full",
                "treeland": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "wlr-screencopy-unstable-v1",
            "name": "wlr screencopy",
            "desc": "screen content capturing on client buffers",
            "descFull": [
                {
                    "title": "wlr screencopy",
                    "text": "This protocol allows clients to ask the compositor to copy part of th creen content to a client buffer.\n\nWarning! The protocol described in this file is experimental an ackward incompatible changes may be made. Backward compatible change ay be added together with the corresponding interface version bump.\nBackward incompatible changes are done by bumping the version number i he protocol and interface names and resetting the interface version.\nOnce the protocol is to be declared stable, the 'z' prefix and th ersion number in the protocol and interface names are removed and th nterface version number is reset."
                },
                {
                    "title": "zwlr_screencopy_manager_v1",
                    "text": "This object is a manager which offers requests to start capturing from  ource."
                },
                {
                    "title": "zwlr_screencopy_frame_v1",
                    "text": "This object represents a single frame.\n\nWhen created, a series of buffer events will be sent, each representing  upported buffer type. The \"buffer_done\" event is sent afterwards t ndicate that all supported buffer types have been enumerated. The clien ill then be able to send a \"copy\" request. If the capture is successful,\nthe compositor will send a \"flags\" event followed by a \"ready\" event.\n\nFor objects version 2 or lower, wl_shm buffers are always supported, ie.\nthe \"buffer\" event is guaranteed to be sent.\n\nIf the capture failed, the \"failed\" event is sent. This can happen anytim efore the \"ready\" event.\n\nOnce either a \"ready\" or a \"failed\" event is received, the client shoul estroy the frame."
                }
            ],
            "tags": {
                "source": "wlr",
                "stability": "unstable"
            },
            "source": "wlr-protocols",
            "supportIf": {
                "zwlr_screencopy_manager_v1": {
                    "sway": 1,
                    "hyprland": 1,
                    "niri": 1,
                    "labwc": 1,
                    "cage": 1,
                    "wayfire": 1,
                    "jay": 1,
                    "mir": 1,
                    "treeland": 1,
                    "louvre": 1
                }
            },
            "supportSum": {
                "sway": "full",
                "hyprland": "full",
                "niri": "full",
                "labwc": "full",
                "cage": "full",
                "wayfire": "full",
                "jay": "full",
                "mir": "full",
                "treeland": "full",
                "louvre": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "wlr-virtual-pointer-unstable-v1",
            "name": "wlr virtual pointer",
            "descFull": [
                {
                    "title": "zwlr_virtual_pointer_v1",
                    "text": "This protocol allows clients to emulate a physical pointer device. Th equests are mostly mirror opposites of those specified in wl_pointer."
                },
                {
                    "title": "zwlr_virtual_pointer_manager_v1",
                    "text": "This object allows clients to create individual virtual pointer objects."
                }
            ],
            "tags": {
                "source": "wlr",
                "stability": "unstable"
            },
            "source": "wlr-protocols",
            "supportIf": {
                "zwlr_virtual_pointer_manager_v1": {
                    "sway": 1,
                    "hyprland": 1,
                    "niri": 1,
                    "labwc": 1,
                    "cage": 1,
                    "wayfire": 1,
                    "mir": 1
                }
            },
            "supportSum": {
                "sway": "full",
                "hyprland": "full",
                "niri": "full",
                "labwc": "full",
                "cage": "full",
                "wayfire": "full",
                "mir": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "input-method-unstable-v2",
            "name": "Input method v2",
            "desc": "Protocol for creating input methods",
            "descFull": [
                {
                    "title": "Input method v2",
                    "text": "This protocol allows applications to act as input methods for compositors.\n\nAn input method context is used to manage the state of the input method.\n\nText strings are UTF-8 encoded, their indices and lengths are in bytes.\n\nThis document adheres to the RFC 2119 when using words like \"must\",\n\"should\", \"may\", etc.\n\nWarning! The protocol described in this file is experimental an ackward incompatible changes may be made. Backward compatible change ay be added together with the corresponding interface version bump.\nBackward incompatible changes are done by bumping the version number i he protocol and interface names and resetting the interface version.\nOnce the protocol is to be declared stable, the 'z' prefix and th ersion number in the protocol and interface names are removed and th nterface version number is reset."
                },
                {
                    "title": "zwp_input_method_v2",
                    "text": "An input method object allows for clients to compose text.\n\nThe objects connects the client to a text input in an application, an ets the client to serve as an input method for a seat.\n\nThe zwp_input_method_v2 object can occupy two distinct states: active an nactive. In the active state, the object is associated to an ommunicates with a text input. In the inactive state, there is n ssociated text input, and the only communication is with the compositor.\nInitially, the input method is in the inactive state.\n\nRequests issued in the inactive state must be accepted by the compositor.\nBecause of the serial mechanism, and the state reset on activate event,\nthey will not have any effect on the state of the next text input.\n\nThere must be no more than one input method object per seat."
                },
                {
                    "title": "zwp_input_popup_surface_v2",
                    "text": "This interface marks a surface as a popup for interacting with an inpu ethod.\n\nThe compositor should place it near the active text input area. It mus e visible if and only if the input method is in the active state.\n\nThe client must not destroy the underlying wl_surface while th wp_input_popup_surface_v2 object exists."
                },
                {
                    "title": "zwp_input_method_keyboard_grab_v2",
                    "text": "The zwp_input_method_keyboard_grab_v2 interface represents an exclusiv rab of the wl_keyboard interface associated with the seat."
                },
                {
                    "title": "zwp_input_method_manager_v2",
                    "text": "The input method manager allows the client to become the input method o  chosen seat.\n\nNo more than one input method must be associated with any seat at an iven time."
                }
            ],
            "tags": {
                "source": "external",
                "stability": "unstable"
            },
            "source": "external",
            "supportIf": {
                "zwp_input_method_manager_v2": {
                    "sway": 1,
                    "cosmic": 1,
                    "hyprland": 1,
                    "niri": 1,
                    "labwc": 1,
                    "jay": 1,
                    "mir": 1,
                    "treeland": 1
                }
            },
            "supportSum": {
                "sway": "full",
                "cosmic": "full",
                "hyprland": "full",
                "niri": "full",
                "labwc": "full",
                "jay": "full",
                "mir": "full",
                "treeland": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "kde-appmenu",
            "name": "KDE AppMenu",
            "descFull": [
                {
                    "title": "org_kde_kwin_appmenu_manager",
                    "text": "This interface allows a client to link a window (or wl_surface) to an com.canonical.dbusmen nterface registered on DBus."
                },
                {
                    "title": "org_kde_kwin_appmenu",
                    "text": "The DBus service name and object path where the appmenu interface is presen he object should be registered on the session bus before sending this request.\nIf not applicable, clients should remove this object."
                }
            ],
            "tags": {
                "source": "kde",
                "stability": "unstable"
            },
            "source": "kde-protocols",
            "supportIf": {
                "org_kde_kwin_appmenu_manager": {
                    "kwin": 1
                }
            },
            "supportSum": {
                "kwin": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "kde-blur",
            "name": "KDE blur",
            "descFull": [],
            "tags": {
                "source": "kde",
                "stability": "unstable"
            },
            "source": "kde-protocols",
            "supportIf": {
                "org_kde_kwin_blur_manager": {
                    "kwin": 1
                }
            },
            "supportSum": {
                "kwin": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "kde-contrast",
            "name": "KDE contrast",
            "descFull": [],
            "tags": {
                "source": "kde",
                "stability": "unstable"
            },
            "source": "kde-protocols",
            "supportIf": {
                "org_kde_kwin_contrast_manager": {
                    "kwin": 1
                }
            },
            "supportSum": {
                "kwin": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "kde-dpms",
            "name": "KDE DPMS",
            "descFull": [
                {
                    "title": "org_kde_kwin_dpms_manager",
                    "text": "The Dpms manager allows to get a org_kde_kwin_dpms for a given wl_output.\nThe org_kde_kwin_dpms provides the currently used VESA Display Power Managemen ignaling state (see https://en.wikipedia.org/wiki/VESA_Display_Power_Management_Signaling ).\nIn addition it allows to request a state change. A compositor is not obliged to honor i nd will normally automatically switch back to on state.\n\nWarning! The protocol described in this file is a desktop environmen mplementation detail. Regular clients must not use this protocol.\nBackward incompatible changes may be added without bumping the majo ersion of the extension."
                },
                {
                    "title": "org_kde_kwin_dpms",
                    "text": "This interface provides information about the VESA DPMS state for a wl_output.\nIt gets created through the request get on the org_kde_kwin_dpms_manager interface.\n\nOn creating the resource the server will push whether DPSM is supported for the output,\nthe currently used DPMS state and notifies the client through the done event once al tates are pushed. Whenever a state changes the set of changes is committed with th one event."
                }
            ],
            "tags": {
                "source": "kde",
                "stability": "unstable"
            },
            "source": "kde-protocols",
            "supportIf": {
                "org_kde_kwin_dpms_manager": {
                    "kwin": 1
                }
            },
            "supportSum": {
                "kwin": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "kde-external-brightness-v1",
            "name": "KDE external brightness",
            "descFull": [
                {
                    "title": "kde_external_brightness_v1",
                    "text": "Some brightness control mechanisms are somewhat unstable, or require roo rivileges, so putting them inside of the compositor is not desired.\nThis protocol is for outsourcing the actual brightness-setting to  rocess outside of the compositor."
                },
                {
                    "title": "kde_external_brightness_device_v1",
                    "text": "After creating this object, the client should issue all relevant setup requests\n(set_internal, set_edid, set_max_brightness, optionally set_observed_brightness)\nand finish the sequence with commit.\nAfterwards, for each change in values, the client must call commit again."
                }
            ],
            "tags": {
                "source": "kde",
                "stability": "unstable"
            },
            "source": "kde-protocols",
            "supportIf": {
                "kde_external_brightness_v1": {
                    "kwin": 1
                }
            },
            "supportSum": {
                "kwin": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "kde-fake-input",
            "name": "KDE fake input",
            "descFull": [
                {
                    "title": "org_kde_kwin_fake_input",
                    "text": "This interface allows other processes to provide fake input events.\nPurpose is on the one hand side to provide testing facilities like XTest on X11.\nBut also to support use case like kdeconnect's mouse pad interface.\n\nA compositor should not trust the input received from this interface.\nClients should not expect that the compositor honors the requests from thi nterface.\n\nWarning! The protocol described in this file is a desktop environmen mplementation detail. Regular clients must not use this protocol.\nBackward incompatible changes may be added without bumping the majo ersion of the extension."
                }
            ],
            "tags": {
                "source": "kde",
                "stability": "unstable"
            },
            "source": "kde-protocols",
            "supportIf": {},
            "supportSum": {},
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "kde-idle",
            "name": "KDE idle",
            "descFull": [
                {
                    "title": "org_kde_kwin_idle",
                    "text": "This interface allows to monitor user idle time on a given seat. The interfac llows to register timers which trigger after no user activity was registere n the seat for a given interval. It notifies when user activity resumes.\n\nThis is useful for applications wanting to perform actions when the user is no nteracting with the system, e.g. chat applications setting the user as away, powe anagement features to dim screen, etc.."
                }
            ],
            "tags": {
                "source": "kde",
                "stability": "unstable",
                "deprecated": "deprecated"
            },
            "source": "kde-protocols",
            "supportIf": {
                "org_kde_kwin_idle": {
                    "kwin": 1
                }
            },
            "supportSum": {
                "kwin": "full"
            },
            "defaultExpand": false,
            "deprecations": {
                "org_kde_kwin_idle": "Use ext-idle-notify",
                "org_kde_kwin_idle_timeout": "Use ext-idle-notify"
            },
            "deprecatedFull": true
        },
        {
            "id": "kde-keystate",
            "name": "KDE key state",
            "descFull": [
                {
                    "title": "org_kde_kwin_keystate",
                    "text": "Keeps track of the states of the different keys that have a state attached to it."
                }
            ],
            "tags": {
                "source": "kde",
                "stability": "unstable"
            },
            "source": "kde-protocols",
            "supportIf": {},
            "supportSum": {},
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "kde-lockscreen-overlay-v1",
            "name": "KDE lockscreen overlay",
            "descFull": [
                {
                    "title": "kde_lockscreen_overlay_v1",
                    "text": "Allows a client to request a surface to be visible when the system is locked.\n\nThis is meant to be used for specific high urgency cases like phone calls or alarms.\n\nWarning! The protocol described in this file is a desktop environmen mplementation detail. Regular clients must not use this protocol.\nBackward incompatible changes may be added without bumping the majo ersion of the extension."
                }
            ],
            "tags": {
                "source": "kde",
                "stability": "unstable"
            },
            "source": "kde-protocols",
            "supportIf": {},
            "supportSum": {},
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "kde-output-management",
            "name": "KDE output management",
            "descFull": [
                {
                    "title": "org_kde_kwin_outputmanagement",
                    "text": "This interface enables clients to set properties of output devices for scree onfiguration purposes via the server. To this end output devices are reference y global org_kde_kwin_outputdevice objects.\n\noutputmanagement (wl_global)\n--------------------------\nrequest:\n* create_configuration -> outputconfiguration (wl_resource)\n\noutputconfiguration (wl_resource)\n--------------------------\nrequests:\n* enable(outputdevice, bool)\n* mode(outputdevice, mode_id)\n* transformation(outputdevice, flag)\n* position(outputdevice, x, y)\n* apply\n\nevents:\n* applied\n* failed\n\nThe server registers one outputmanagement object as a global object. In orde o configure outputs a client requests create_configuration, which provides  esource referencing an outputconfiguration for one-time configuration. Tha ay the server knows which requests belong together and can group them by that.\n\nOn the outputconfiguration object the client calls for each output whether th utput should be enabled, which mode should be set (by referencing the mode fro he list of announced modes) and the output's global position. Once all output re configured that way, the client calls apply.\nAt that point and not earlier the server should try to apply the configuration.\nIf this succeeds the server emits the applied signal, otherwise the faile ignal, such that the configuring client is noticed about the success of it onfiguration request.\n\nThrough this design the interface enables atomic output configuration changes i nternally supported by the server."
                },
                {
                    "title": "org_kde_kwin_outputconfiguration",
                    "text": "outputconfiguration is a client-specific resource that can be used to as he server to apply changes to available output devices.\n\nThe client receives a list of output devices from the registry. When it want o apply new settings, it creates a configuration object from th utputmanagement global, writes changes through this object's enable, scale,\ntransform and mode calls. It then asks the server to apply these settings i n atomic fashion, for example through Linux' DRM interface.\n\nThe server signals back whether the new settings have applied successfull r failed to apply. outputdevice objects are updated after the changes have bee pplied to the hardware and before the server side sends the applied event."
                }
            ],
            "tags": {
                "source": "kde",
                "stability": "unstable"
            },
            "source": "kde-protocols",
            "supportIf": {},
            "supportSum": {},
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "kde-output-management-v2",
            "name": "KDE output management v2",
            "descFull": [
                {
                    "title": "kde_output_management_v2",
                    "text": "This interface enables clients to set properties of output devices for scree onfiguration purposes via the server. To this end output devices are reference y global kde_output_device_v2 objects.\n\noutputmanagement (wl_global)\n--------------------------\nrequest:\n* create_configuration -> outputconfiguration (wl_resource)\n\noutputconfiguration (wl_resource)\n--------------------------\nrequests:\n* enable(outputdevice, bool)\n* mode(outputdevice, mode)\n* transformation(outputdevice, flag)\n* position(outputdevice, x, y)\n* apply\n\nevents:\n* applied\n* failed\n\nThe server registers one outputmanagement object as a global object. In orde o configure outputs a client requests create_configuration, which provides  esource referencing an outputconfiguration for one-time configuration. Tha ay the server knows which requests belong together and can group them by that.\n\nOn the outputconfiguration object the client calls for each output whether th utput should be enabled, which mode should be set (by referencing the mode fro he list of announced modes) and the output's global position. Once all output re configured that way, the client calls apply.\nAt that point and not earlier the server should try to apply the configuration.\nIf this succeeds the server emits the applied signal, otherwise the faile ignal, such that the configuring client is noticed about the success of it onfiguration request.\n\nThrough this design the interface enables atomic output configuration changes i nternally supported by the server.\n\nWarning! The protocol described in this file is a desktop environment implementatio etail. Regular clients must not use this protocol. Backward incompatibl hanges may be added without bumping the major version of the extension."
                },
                {
                    "title": "kde_output_configuration_v2",
                    "text": "outputconfiguration is a client-specific resource that can be used to as he server to apply changes to available output devices.\n\nThe client receives a list of output devices from the registry. When it want o apply new settings, it creates a configuration object from th utputmanagement global, writes changes through this object's enable, scale,\ntransform and mode calls. It then asks the server to apply these settings i n atomic fashion, for example through Linux' DRM interface.\n\nThe server signals back whether the new settings have applied successfull r failed to apply. outputdevice objects are updated after the changes have bee pplied to the hardware and before the server side sends the applied event."
                }
            ],
            "tags": {
                "source": "kde",
                "stability": "unstable"
            },
            "source": "kde-protocols",
            "supportIf": {
                "kde_output_management_v2": {
                    "kwin": 1
                }
            },
            "supportSum": {
                "kwin": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "kde-outputdevice",
            "name": "KDE output device",
            "descFull": [
                {
                    "title": "org_kde_kwin_outputdevice",
                    "text": "An outputdevice describes a display device available to the compositor.\noutputdevice is similar to wl_output, but focuses on outpu onfiguration management.\n\nA client can query all global outputdevice objects to enlist al vailable display devices, even those that may currently not b epresented by the compositor as a wl_output.\n\nThe client sends configuration changes to the server through th utputconfiguration interface, and the server applies the configuratio hanges to the hardware and signals changes to the outputdevice ccordingly.\n\nThis object is published as global during start up for every availabl isplay devices, or when one later becomes available, for example b eing hotplugged via a physical connector."
                }
            ],
            "tags": {
                "source": "kde",
                "stability": "unstable"
            },
            "source": "kde-protocols",
            "supportIf": {},
            "supportSum": {},
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "kde-output-device-v2",
            "name": "KDE output device v2",
            "descFull": [
                {
                    "title": "kde_output_device_v2",
                    "text": "An output device describes a display device available to the compositor.\noutput_device is similar to wl_output, but focuses on outpu onfiguration management.\n\nA client can query all global output_device objects to enlist al vailable display devices, even those that may currently not b epresented by the compositor as a wl_output.\n\nThe client sends configuration changes to the server through th utputconfiguration interface, and the server applies the configuratio hanges to the hardware and signals changes to the output device ccordingly.\n\nThis object is published as global during start up for every availabl isplay devices, or when one later becomes available, for example b eing hotplugged via a physical connector.\n\nWarning! The protocol described in this file is a desktop environmen mplementation detail. Regular clients must not use this protocol.\nBackward incompatible changes may be added without bumping the majo ersion of the extension."
                },
                {
                    "title": "kde_output_device_mode_v2",
                    "text": "This object describes an output mode.\n\nSome heads don't support output modes, in which case modes won't b dvertised.\n\nProperties sent via this interface are applied atomically via th de_output_device.done event. No guarantees are made regarding the orde n which properties are sent."
                }
            ],
            "tags": {
                "source": "kde",
                "stability": "unstable"
            },
            "source": "kde-protocols",
            "supportIf": {
                "kde_output_device_v2": {
                    "kwin": 1
                }
            },
            "supportSum": {
                "kwin": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "kde-output-order-v1",
            "name": "KDE output order",
            "descFull": [
                {
                    "title": "kde_output_order_v1",
                    "text": "Announce the order in which desktop environment components should be placed on outputs.\nThe compositor will send the list of outputs when the global is bound and whenever there is a change.\n\nWarning! The protocol described in this file is a desktop environmen mplementation detail. Regular clients must not use this protocol.\nBackward incompatible changes may be added without bumping the majo ersion of the extension."
                }
            ],
            "tags": {
                "source": "kde",
                "stability": "unstable"
            },
            "source": "kde-protocols",
            "supportIf": {
                "kde_output_order_v1": {
                    "kwin": 1
                }
            },
            "supportSum": {
                "kwin": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "kde-plasma-shell",
            "name": "KDE plasma shell",
            "descFull": [
                {
                    "title": "org_kde_plasma_shell",
                    "text": "This interface is used by KF5 powered Wayland shells to communicate wit he compositor and can only be bound one time.\n\nWarning! The protocol described in this file is a desktop environmen mplementation detail. Regular clients must not use this protocol.\nBackward incompatible changes may be added without bumping the majo ersion of the extension."
                },
                {
                    "title": "org_kde_plasma_surface",
                    "text": "An interface that may be implemented by a wl_surface, fo mplementations that provide the shell user interface.\n\nIt provides requests to set surface roles, assign an outpu r set the position in output coordinates.\n\nOn the server side the object is automatically destroyed whe he related wl_surface is destroyed.  On client side,\norg_kde_plasma_surface.destroy() must be called befor estroying the wl_surface object."
                }
            ],
            "tags": {
                "source": "kde",
                "stability": "unstable"
            },
            "source": "kde-protocols",
            "supportIf": {
                "org_kde_plasma_shell": {
                    "kwin": 1
                }
            },
            "supportSum": {
                "kwin": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "kde-plasma-virtual-desktop",
            "name": "KDE plasma virtual desktop",
            "descFull": [],
            "tags": {
                "source": "kde",
                "stability": "unstable"
            },
            "source": "kde-protocols",
            "supportIf": {
                "org_kde_plasma_virtual_desktop_management": {
                    "kwin": 1
                }
            },
            "supportSum": {
                "kwin": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "kde-plasma-window-management",
            "name": "KDE plasma window management",
            "descFull": [
                {
                    "title": "org_kde_plasma_window_management",
                    "text": "This interface manages application windows.\nIt provides requests to show and hide the desktop and emit n event every time a window is created so that the client ca se it to manage the window.\n\nOnly one client can bind this interface at a time.\n\nWarning! The protocol described in this file is a desktop environmen mplementation detail. Regular clients must not use this protocol.\nBackward incompatible changes may be added without bumping the majo ersion of the extension."
                },
                {
                    "title": "org_kde_plasma_window",
                    "text": "Manages and control an application window.\n\nOnly one client can bind this interface at a time."
                },
                {
                    "title": "org_kde_plasma_activation_feedback",
                    "text": "The activation manager interface provides a way to get notifie hen an application is about to be activated."
                },
                {
                    "title": "org_kde_plasma_stacking_order",
                    "text": "When this object is created, the compositor sends a window event fo ach window in the stacking order, and afterwards sends the done even nd destroys this object."
                }
            ],
            "tags": {
                "source": "kde",
                "stability": "unstable"
            },
            "source": "kde-protocols",
            "supportIf": {},
            "supportSum": {},
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "kde-primary-output-v1",
            "name": "KDE primary output",
            "descFull": [
                {
                    "title": "kde_primary_output_v1",
                    "text": "Protocol for telling which is the primary display among the selectio f enabled outputs.\n\nWarning! The protocol described in this file is a desktop environmen mplementation detail. Regular clients must not use this protocol.\nBackward incompatible changes may be added without bumping the majo ersion of the extension."
                }
            ],
            "tags": {
                "source": "kde",
                "stability": "unstable"
            },
            "source": "kde-protocols",
            "supportIf": {},
            "supportSum": {},
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "kde-screen-edge-v1",
            "name": "KDE screen edge",
            "descFull": [
                {
                    "title": "kde_screen_edge_manager_v1",
                    "text": "This interface allows clients to associate actions with screen edges. Fo xample, showing a surface by moving the pointer to a screen edge.\n\nPotential ways to trigger the screen edge are subject to composito olicies. As an example, the compositor may consider the screen edge to b riggered if the pointer hits its associated screen border. Other ways ma nclude using touchscreen or touchpad gestures.\n\nWarning! The protocol described in this file is a desktop environmen mplementation detail. Regular clients must not use this protocol.\nBackward incompatible changes may be added without bumping the majo ersion of the extension."
                },
                {
                    "title": "kde_auto_hide_screen_edge_v1",
                    "text": "The auto hide screen edge object allows to hide the surface and make i isible by triggering the screen edge. The screen edge is inactive an he surface is visible by default.\n\nThis interface can be used to implement user interface elements such a uto-hide panels or docks.\n\nkde_auto_hide_screen_edge_v1.activate activates the screen edge and make he surface hidden. The surface can be made visible by triggering th creen edge or calling kde_auto_hide_screen_edge_v1.deactivate.\n\nIf the screen edge has been triggered, it won't be re-activated again.\nAnother kde_auto_hide_screen_edge_v1.activate request must be made by th lient to activate the screen edge."
                }
            ],
            "tags": {
                "source": "kde",
                "stability": "unstable"
            },
            "source": "kde-protocols",
            "supportIf": {
                "kde_screen_edge_manager_v1": {
                    "kwin": 1
                }
            },
            "supportSum": {
                "kwin": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "kde-zkde-screencast-unstable-v1",
            "name": "KDE screencast",
            "descFull": [
                {
                    "title": "zkde_screencast_unstable_v1",
                    "text": "Warning! The protocol described in this file is a desktop environmen mplementation detail. Regular clients must not use this protocol.\nBackward incompatible changes may be added without bumping the majo ersion of the extension."
                }
            ],
            "tags": {
                "source": "kde",
                "stability": "unstable"
            },
            "source": "kde-protocols",
            "supportIf": {},
            "supportSum": {},
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "kde-server-decoration",
            "name": "KDE server decoration",
            "descFull": [
                {
                    "title": "org_kde_kwin_server_decoration_manager",
                    "text": "This interface allows to coordinate whether the server should creat  server-side window decoration around a wl_surface representing  hell surface (wl_shell_surface or similar). By announcing suppor or this interface the server indicates that it supports serve ide decorations.\n\nUse in conjunction with zxdg_decoration_manager_v1 is undefined."
                }
            ],
            "tags": {
                "source": "kde",
                "stability": "unstable",
                "deprecated": "deprecated"
            },
            "source": "kde-protocols",
            "supportIf": {
                "org_kde_kwin_server_decoration_manager": {
                    "kwin": 1,
                    "sway": 1,
                    "cosmic": 1,
                    "hyprland": 1,
                    "niri": 1,
                    "labwc": 1,
                    "cage": 1,
                    "wayfire": 1,
                    "jay": 1
                }
            },
            "supportSum": {
                "kwin": "full",
                "sway": "full",
                "cosmic": "full",
                "hyprland": "full",
                "niri": "full",
                "labwc": "full",
                "cage": "full",
                "wayfire": "full",
                "jay": "full"
            },
            "defaultExpand": false,
            "deprecations": {
                "org_kde_kwin_server_decoration_manager": "Use xdg-decoration",
                "org_kde_kwin_server_decoration": "Use xdg-decoration"
            },
            "deprecatedFull": true
        },
        {
            "id": "kde-server-decoration-palette",
            "name": "KDE server decoration palette",
            "descFull": [
                {
                    "title": "org_kde_kwin_server_decoration_palette_manager",
                    "text": "This interface allows a client to alter the palette of a server side decoration."
                },
                {
                    "title": "org_kde_kwin_server_decoration_palette",
                    "text": "This interface allows a client to alter the palette of a server side decoration."
                }
            ],
            "tags": {
                "source": "kde",
                "stability": "unstable"
            },
            "source": "kde-protocols",
            "supportIf": {
                "org_kde_kwin_server_decoration_palette_manager": {
                    "kwin": 1
                }
            },
            "supportSum": {
                "kwin": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "kde-shadow",
            "name": "KDE shadow",
            "descFull": [],
            "tags": {
                "source": "kde",
                "stability": "unstable"
            },
            "source": "kde-protocols",
            "supportIf": {
                "org_kde_kwin_shadow_manager": {
                    "kwin": 1
                }
            },
            "supportSum": {
                "kwin": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "kde-slide",
            "name": "KDE slide",
            "descFull": [
                {
                    "title": "org_kde_kwin_slide",
                    "text": "Ask the compositor to move the surface from a location to anothe ith a slide animation.\n\nThe from argument provides a clue about where the slide animatio egins, offset is the distance from screen edge to begin the animation."
                }
            ],
            "tags": {
                "source": "kde",
                "stability": "unstable"
            },
            "source": "kde-protocols",
            "supportIf": {
                "org_kde_kwin_slide_manager": {
                    "kwin": 1
                }
            },
            "supportSum": {
                "kwin": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "hyprland-ctm-control-v1",
            "name": "Hyprland color transform matrix control",
            "desc": "controlling outputs' color transform matrix",
            "descFull": [
                {
                    "title": "Hyprland color transform matrix control",
                    "text": "This protocol allows a client to control outputs' color transform matrix (CTM).\n\nThis protocol is privileged and should not be exposed to unprivileged clients."
                },
                {
                    "title": "hyprland_ctm_control_manager_v1",
                    "text": "This object is a manager which offers requests to control CTMs.\n\nIf any changes are done, once this object is destroyed, CTMs are reset back t n identity matrix."
                }
            ],
            "tags": {
                "source": "hyprland",
                "stability": "unstable"
            },
            "source": "hyprland-protocols",
            "supportIf": {
                "hyprland_ctm_control_manager_v1": {
                    "hyprland": 1
                }
            },
            "supportSum": {
                "hyprland": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "hyprland-focus-grab-v1",
            "name": "Hyprland focus grab",
            "desc": "limit input focus to a set of surfaces",
            "descFull": [
                {
                    "title": "Hyprland focus grab",
                    "text": "This protocol allows clients to limit input focus to a specific se f surfaces and receive a notification when the limiter is removed a etailed below."
                },
                {
                    "title": "hyprland_focus_grab_manager_v1",
                    "text": "This interface allows a client to create surface grab objects."
                },
                {
                    "title": "hyprland_focus_grab_v1",
                    "text": "This interface restricts input focus to a specified whitelist o urfaces as long as the focus grab object exists and has at leas ne comitted surface.\n\nMouse and touch events inside a whitelisted surface will be passe o the surface normally, while events outside of a whitelisted surfac ill clear the grab object. Keyboard events will be passed to the clien nd a compositor-picked surface in the whitelist will receive  l_keyboard::enter event if a whitelisted surface is not already entered.\n\nUpon meeting implementation-defined criteria usually meaning a mouse o ouch input outside of any whitelisted surfaces, the compositor wil lear the whitelist, rendering the grab inert and sending the cleare vent. The same will happen if another focus grab or similar actio s started at the compositor's discretion."
                }
            ],
            "tags": {
                "source": "hyprland",
                "stability": "unstable"
            },
            "source": "hyprland-protocols",
            "supportIf": {
                "hyprland_focus_grab_manager_v1": {
                    "hyprland": 1
                }
            },
            "supportSum": {
                "hyprland": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "hyprland-global-shortcuts-v1",
            "name": "Hyprland global shortcuts",
            "desc": "registering global shortcuts",
            "descFull": [
                {
                    "title": "Hyprland global shortcuts",
                    "text": "This protocol allows a client to register triggerable actions,\nmeant to be global shortcuts."
                },
                {
                    "title": "hyprland_global_shortcuts_manager_v1",
                    "text": "This object is a manager which offers requests to create global shortcuts."
                },
                {
                    "title": "hyprland_global_shortcut_v1",
                    "text": "This object represents a single shortcut."
                }
            ],
            "tags": {
                "source": "hyprland",
                "stability": "unstable"
            },
            "source": "hyprland-protocols",
            "supportIf": {
                "hyprland_global_shortcuts_manager_v1": {
                    "hyprland": 1
                }
            },
            "supportSum": {
                "hyprland": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "hyprland-surface-v1",
            "name": "Hyprland surface",
            "desc": "hyprland-specific wl_surface extensions",
            "descFull": [
                {
                    "title": "Hyprland surface",
                    "text": "This protocol exposes hyprland-specific wl_surface properties."
                },
                {
                    "title": "hyprland_surface_manager_v1",
                    "text": "This interface allows a client to create hyprland surface objects."
                },
                {
                    "title": "hyprland_surface_v1",
                    "text": "This interface allows access to hyprland-specific properties of a wl_surface.\n\nOnce the wl_surface has been destroyed, the hyprland surface object must b estroyed as well. All other operations are a protocol error."
                }
            ],
            "tags": {
                "source": "hyprland",
                "stability": "unstable"
            },
            "source": "hyprland-protocols",
            "supportIf": {
                "hyprland_surface_manager_v1": {
                    "hyprland": 1
                }
            },
            "supportSum": {
                "hyprland": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "hyprland-toplevel-export-v1",
            "name": "Hyprland toplevel export",
            "desc": "capturing the contents of toplevel windows",
            "descFull": [
                {
                    "title": "Hyprland toplevel export",
                    "text": "This protocol allows clients to ask for exporting another toplevel' urface(s) to a buffer.\n\nParticularly useful for sharing a single window."
                },
                {
                    "title": "hyprland_toplevel_export_manager_v1",
                    "text": "This object is a manager which offers requests to start capturing from  ource."
                },
                {
                    "title": "hyprland_toplevel_export_frame_v1",
                    "text": "This object represents a single frame.\n\nWhen created, a series of buffer events will be sent, each representing  upported buffer type. The \"buffer_done\" event is sent afterwards t ndicate that all supported buffer types have been enumerated. The clien ill then be able to send a \"copy\" request. If the capture is successful,\nthe compositor will send a \"flags\" followed by a \"ready\" event.\n\nwl_shm buffers are always supported, ie. the \"buffer\" event is guaranteed to be sent.\n\nIf the capture failed, the \"failed\" event is sent. This can happen anytim efore the \"ready\" event.\n\nOnce either a \"ready\" or a \"failed\" event is received, the client shoul estroy the frame."
                }
            ],
            "tags": {
                "source": "hyprland",
                "stability": "unstable"
            },
            "source": "hyprland-protocols",
            "supportIf": {
                "hyprland_toplevel_export_manager_v1": {
                    "hyprland": 1
                }
            },
            "supportSum": {
                "hyprland": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "hyprland-lock-notify-v1",
            "name": "Hyprland lock notify",
            "descFull": [
                {
                    "title": "hyprland_lock_notifier_v1",
                    "text": "This interface allows clients to monitor whether the wayland session i ocked or unlocked."
                },
                {
                    "title": "hyprland_lock_notification_v1",
                    "text": "This interface is used by the compositor to send lock notification event o clients.\n\nTypically the \"locked\" and \"unlocked\" events are emitted when a clien ocks/unlocks the session via ext-session-lock, but the compositor ma hoose to send notifications for any other locking mechanisms.\n\nThe compositor must notfiy after possible transition period etween locked and unlocked states of the session.\nIn the context of ext-session-lock, that means the \"locked\" event i xpected to be sent after the session-lock client has presente  lock screen frame on every output, which corresponds to the \"locked\"\nevent of ext-session-lock."
                }
            ],
            "tags": {
                "source": "hyprland",
                "stability": "unstable"
            },
            "source": "hyprland-protocols",
            "supportIf": {
                "hyprland_lock_notifier_v1": {
                    "hyprland": 1
                }
            },
            "supportSum": {
                "hyprland": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "hyprland-toplevel-mapping-v1",
            "name": "Hyprland toplevel mapping",
            "desc": "mapping of toplevels to windows",
            "descFull": [
                {
                    "title": "Hyprland toplevel mapping",
                    "text": "This protocol allows clients to retrieve the mapping of toplevels to hyprland window addresses."
                },
                {
                    "title": "hyprland_toplevel_mapping_manager_v1",
                    "text": "This object is a manager which offers requests to retrieve a window addres or a toplevel."
                },
                {
                    "title": "hyprland_toplevel_window_mapping_handle_v1",
                    "text": "This object represents a mapping of a (wlr) toplevel to a window address.\n\nOnce created, the `window_address` event will be sent containing the address of the windo ssociated with the toplevel.\nShould the mapping fail, the `failed` event will be sent."
                }
            ],
            "tags": {
                "source": "hyprland",
                "stability": "unstable"
            },
            "source": "hyprland-protocols",
            "supportIf": {},
            "supportSum": {},
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "cosmic-image-source-unstable-v1",
            "name": "COSMIC image source",
            "desc": "opaque image source objects",
            "descFull": [
                {
                    "title": "COSMIC image source",
                    "text": "This protocol serves as an intermediary between screen capturing protocol nd potential image sources such as outputs and toplevels.\n\nThis protocol may be extended to support more image sources in the future,\nthereby adding those image sources to other protocols that use the imag ource object without having to modify those protocols.\n\nWarning! The protocol described in this file is currently in the testin hase. Backward compatible changes may be added together with th orresponding interface version bump. Backward incompatible changes ca nly be done by creating a new major version of the extension."
                },
                {
                    "title": "zcosmic_image_source_v1",
                    "text": "The image source object is an opaque descriptor for a capturable resource.\nThis resource may be any sort of entity from which an image may b erived.\n\nNote, because zcosmic_image_source_v1 objects are created from multipl ndependent factory interfaces, the zcosmic_image_source_v1 interface i rozen at version 1."
                },
                {
                    "title": "zcosmic_output_image_source_manager_v1",
                    "text": "A manager for creating image source objects for wl_output objects."
                },
                {
                    "title": "zcosmic_workspace_image_source_manager_v1",
                    "text": "A manager for creating image source objects for wl_output objects."
                },
                {
                    "title": "zcosmic_toplevel_image_source_manager_v1",
                    "text": "A manager for creating image source objects fo cosmic_toplevel_handle_v1 objects."
                }
            ],
            "tags": {
                "source": "cosmic",
                "stability": "unstable"
            },
            "source": "cosmic-protocols",
            "supportIf": {
                "zcosmic_output_image_source_manager_v1": {
                    "cosmic": 1
                },
                "zcosmic_toplevel_image_source_manager_v1": {
                    "cosmic": 1
                },
                "zcosmic_workspace_image_source_manager_v1": {
                    "cosmic": 1
                }
            },
            "supportSum": {
                "cosmic": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "cosmic-output-management-unstable-v1",
            "name": "COSMIC output managment",
            "desc": "extension protocol to wlr-output-management",
            "descFull": [
                {
                    "title": "COSMIC output managment",
                    "text": "This protocol serves as an extension to wlr-output-management.\n\nIt primarily adds explicit output mirroring,\nwhile upstream is figuring out how to best support that.\n\nIt was designed against version 4 of wlr-output-management, but trie t's best to be forward compatible."
                },
                {
                    "title": "zcosmic_output_manager_v1",
                    "text": "This interface provides extension points for wlr-output-management types."
                },
                {
                    "title": "zcosmic_output_head_v1",
                    "text": "Extension to zwlr_output_head_v1.\n\nAdds additional read-only properties.\n\nProperties sent via this interface are applied atomically via the wlr_output_manager.done event.\nNo guarantees are made regarding the order in which properties are sent."
                },
                {
                    "title": "zcosmic_output_configuration_v1",
                    "text": "Extension to zwlr_output_configuration_v1.\n\nAdds additional parameters to be tested/applyed via the original zwlr_output_configuration_v1."
                },
                {
                    "title": "zcosmic_output_configuration_head_v1",
                    "text": "Extension to zwlr_output_configuration_head_v1.\n\nAdds additional/alternative parameters to the original zwlr_output_configuration_head_v1.\n\nOnce the original `zwlr_output_configuration_head_v1` is destroyed this object will also be destroyed."
                }
            ],
            "tags": {
                "source": "cosmic",
                "stability": "unstable"
            },
            "source": "cosmic-protocols",
            "supportIf": {
                "zcosmic_output_manager_v1": {
                    "cosmic": 1
                }
            },
            "supportSum": {
                "cosmic": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "cosmic-screencopy-unstable-v1",
            "name": "COSMIC screencopy v1",
            "desc": "screen content capturing on client buffers",
            "descFull": [
                {
                    "title": "COSMIC screencopy v1",
                    "text": "This protocol allows clients to ask the compositor to copy part of th creen content to a client buffer.\n\nWarning! The protocol described in this file is experimental an ackward incompatible changes may be made. Backward compatible change ay be added together with the corresponding interface version bump.\nBackward incompatible changes are done by bumping the version number i he protocol and interface names and resetting the interface version.\nOnce the protocol is to be declared stable, the 'z' prefix and th ersion number in the protocol and interface names are removed and th nterface version number is reset."
                },
                {
                    "title": "zcosmic_screencopy_manager_v1",
                    "text": "This object is a manager which offers requests to start capturing from  ource."
                },
                {
                    "title": "zcosmic_screencopy_session_v1",
                    "text": "This object represents a session that's being captured.\n\nAfter a screencopy session is created, buffer_info events will be emitte rom the compositor to tell the client which buffer types and formats ar upported for reading from the surface.\n\nWhen the client knows all the buffer attributes, it can create a buffer,\nattach it to the screencopy surface using the \"attach_buffer\" request,\nset the buffer damage using the \"damage_buffer\" request and then cal he \"commit\" request.\n\nAfter \"commit\" has been called, the next time that a buffer is committe y the compositor, the contents of that buffer will be copied to the on ommitted to the screencopy session. A series of events will be generated,\nending with the \"ready\" event, which means that the buffer is ready to b sed and a buffer may be committed to the surface again.\n\nThe \"failed\" event may be sent at any time. When this happens, the clien ust destroy the session. Depending on the failure reason, the client ca reate a new session to replace it."
                }
            ],
            "tags": {
                "source": "cosmic",
                "stability": "unstable"
            },
            "source": "cosmic-protocols",
            "supportIf": {},
            "supportSum": {},
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "cosmic-screencopy-unstable-v2",
            "name": "COSMIC screencopy v2",
            "desc": "screen content capturing on client buffers",
            "descFull": [
                {
                    "title": "COSMIC screencopy v2",
                    "text": "This protocol allows clients to ask the compositor to capture scree ontents to user submitted buffers.\n\nWarning! The protocol described in this file is currently in the testin hase. Backward compatible changes may be added together with th orresponding interface version bump. Backward incompatible changes ca nly be done by creating a new major version of the extension."
                },
                {
                    "title": "zcosmic_screencopy_manager_v2",
                    "text": "This object is a manager which offers requests to start capturing from  ource."
                },
                {
                    "title": "zcosmic_screencopy_session_v2",
                    "text": "This object represents an active screencopy session.\n\nAfter a screencopy session is created, buffer constraint events will b mitted from the compositor to tell the client which buffer types an ormats are supported for reading from the session. The compositor ma e-send buffer constraint events whenever they change.\n\nThe advertise buffer constraints, the compositor must send in n articular order: zero or more shm_format and dmabuf_format events, zer r one dmabuf_device event, and exactly one buffer_size event. Then th ompositor must send a done event.\n\nWhen the client has received all the buffer constraints, it can create  uffer accordingly, attach it to the screencopy session using th ttach_buffer request, set the buffer damage using the damage_buffe equest and then send the capture request."
                },
                {
                    "title": "zcosmic_screencopy_frame_v2",
                    "text": "This object represents a screen capture frame.\n\nThe client should attach a buffer, damage the buffer, and then send  apture request.\n\nIf the screen capture is successful, the compositor will send the fram etadata (transform, damage, presentation_time in any order) followed b he ready event.\n\nIf the screen capture fails, the compositor will send the failed event."
                },
                {
                    "title": "zcosmic_screencopy_cursor_session_v2",
                    "text": "This object represents a cursor capture session. It extends the bas apture session with cursor-specific metadata."
                }
            ],
            "tags": {
                "source": "cosmic",
                "stability": "unstable"
            },
            "source": "cosmic-protocols",
            "supportIf": {
                "zcosmic_screencopy_manager_v2": {
                    "cosmic": 1
                }
            },
            "supportSum": {
                "cosmic": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "cosmic-toplevel-info-unstable-v1",
            "name": "COSMIC toplevel info",
            "descFull": [
                {
                    "title": "zcosmic_toplevel_info_v1",
                    "text": "The purpose of this protocol is to enable clients such as taskbar r docks to access a list of opened applications and basic propertie hereof.\n\nThe secondary purpose of this protocol is to provide protocol objec andles for toplevels which may be used to address said toplevels i ther protocols (e.g. to target a toplevel for screencopy).\n\nAfter a client binds the zcosmic_toplevel_info_v1, each opene oplevel window will be sent via the toplevel event"
                },
                {
                    "title": "zcosmic_toplevel_handle_v1",
                    "text": "A zcosmic_toplevel_handle_v1 object represents an open topleve indow.  A single app may have multiple open toplevels.\n\nEach toplevel has a list of outputs it is visible on, exposed to th lient via the output_enter and output_leave events."
                }
            ],
            "tags": {
                "source": "cosmic",
                "stability": "unstable"
            },
            "source": "cosmic-protocols",
            "supportIf": {
                "zcosmic_toplevel_info_v1": {
                    "cosmic": 1
                }
            },
            "supportSum": {
                "cosmic": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "cosmic-toplevel-management-unstable-v1",
            "name": "COSMIC toplevel management",
            "descFull": [
                {
                    "title": "zcosmic_toplevel_manager_v1",
                    "text": "This protocol allows clients such as a taskbar to request the composito o preform typical actions on open toplevels. The compositor is in al ases free to ignore the request."
                }
            ],
            "tags": {
                "source": "cosmic",
                "stability": "unstable"
            },
            "source": "cosmic-protocols",
            "supportIf": {
                "zcosmic_toplevel_manager_v1": {
                    "cosmic": 1
                }
            },
            "supportSum": {
                "cosmic": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "cosmic-workspace-unstable-v1",
            "name": "COSMIC workspace",
            "descFull": [
                {
                    "title": "zcosmic_workspace_manager_v1",
                    "text": "Workspaces, also called virtual desktops, are groups of surfaces.  ompositor with a concept of workspaces may only show some such groups o urfaces (those of 'active' workspaces) at a time.'Activating'  orkspace is a request for the compositor to display that workspace' urfaces as normal, whereas the compositor may hide or otherwis e-emphasise surfaces that are associated only with 'inactive' workspaces.\nWorkspaces are grouped by which sets of outputs they correspond to, an ay contain surfaces only from those outputs. In this way, it is possibl or each output to have its own set of workspaces, or for all outputs (o ny other arbitrary grouping) to share workspaces. Compositors ma ptionally conceptually arrange each group of workspaces in a -dimensional grid.\n\nThe purpose of this protocol is to enable the creation of taskbars an ocks by providing them with a list of workspaces and their properties,\nand allowing them to activate and deactivate workspaces.\n\nAfter a client binds the zcosmic_workspace_manager_v1, each workspace will b ent via the workspace event."
                },
                {
                    "title": "zcosmic_workspace_group_handle_v1",
                    "text": "A zcosmic_workspace_group_handle_v1 object represents a a workspace grou hat is assigned a set of outputs and contains a number of workspaces.\n\nThe set of outputs assigned to the workspace group is conveyed to the client vi utput_enter and output_leave events, and its workspaces are conveyed wit orkspace events.\n\nFor example, a compositor which has a set of workspaces for each output ma dvertise a workspace group (and its workspaces) per output, whereas a composito here a workspace spans all outputs may advertise a single workspace group for al utputs."
                },
                {
                    "title": "zcosmic_workspace_handle_v1",
                    "text": "A zcosmic_workspace_handle_v1 object represents a a workspace that handles  roup of surfaces.\n\nEach workspace has a name, conveyed to the client with the name event;  ist of states, conveyed to the client with the state event; an ptionally a set of coordinates, conveyed to the client with th oordinates event. The client may request that the compositor activate o eactivate the workspace.\n\nEach workspace can belong to only a single workspace group.\nDepepending on the compositor policy, there might be workspaces wit he same name in different workspace groups, but these workspaces are stil eparate (e.g. one of them might be active while the other is not)."
                }
            ],
            "tags": {
                "source": "cosmic",
                "stability": "unstable"
            },
            "source": "cosmic-protocols",
            "supportIf": {
                "zcosmic_workspace_manager_v1": {
                    "cosmic": 1,
                    "labwc": 1
                }
            },
            "supportSum": {
                "cosmic": "full",
                "labwc": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "ivi-application",
            "name": "In-vehicle infotainment application",
            "descFull": [
                {
                    "title": "ivi_application",
                    "text": "This interface is exposed as a global singleton.\nThis interface is implemented by servers that provide IVI-style user interfaces.\nIt allows clients to associate an ivi_surface with wl_surface."
                }
            ],
            "tags": {
                "source": "weston",
                "stability": "unstable"
            },
            "source": "weston-protocols",
            "supportIf": {},
            "supportSum": {},
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "ivi-hmi-controller",
            "name": "In-vehicle infotainment HMI controller",
            "descFull": [],
            "tags": {
                "source": "weston",
                "stability": "unstable"
            },
            "source": "weston-protocols",
            "supportIf": {},
            "supportSum": {},
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "text-cursor-position",
            "name": "Text cursor position",
            "descFull": [],
            "tags": {
                "source": "weston",
                "stability": "unstable"
            },
            "source": "weston-protocols",
            "supportIf": {},
            "supportSum": {},
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "weston-content-protection",
            "name": "Weston content protection",
            "desc": "Protocol for providing secure output",
            "descFull": [
                {
                    "title": "Weston content protection",
                    "text": "This protocol specifies a set of interfaces used to provid ontent-protection for e.g. HDCP, and protect surface contents on th ecured outputs and prevent from appearing in screenshots or from bein isible on non-secure outputs.\n\nA secure-output is defined as an output that is secured by som ontent-protection mechanism e.g. HDCP, and meets at least the minimu equired content-protection level requested by a client.\n\nThe term content-protection is defined in terms of HDCP type 0 an DCP type 1, but this may be extended in future.\n\nThis protocol is not intended for implementing Digital Rights Management o eneral (e.g. Desktop) systems, and would only be useful for closed systems.\nAs the server is the one responsible for implementin he content-protection, the client can only trust the content-protection a uch they can trust the server.\n\nIn order to protect the content and prevent surface contents from appearin n screenshots or from being visible on non-secure outputs, a client mus irst bind the global interface \"weston_content_protection\" which, if  ompositor supports secure output, is exposed by the registry.\nUsing the bound global object, the client uses the \"get_protection\" reques o instantiate an interface extension for a wl_surface object.\nThis extended interface will then allow surfaces to request fo ontent-protection, and also to censor the visibility of the surface o on-secure outputs. Client applications should not wait for the protectio o change, as it might never change in case the content-protection cannot b chieved. Alternatively, clients can use a timeout and start showing th ontent in lower quality.\n\nCensored visibility is defined as the compositor censoring the protecte ontent on non-secure outputs. Censoring may include artificially reducin mage quality or replacing the protected content completely wit laceholder graphics.\n\nCensored visibility is controlled by protection mode, set by the client.\nIn \"relax\" mode, the compositor may show protected content on non-secur utputs. It will be up to the client to adapt to secure and non-secur resentation. In \"enforce\" mode, the compositor will censor the parts o rotected content that would otherwise show on non-secure outputs."
                },
                {
                    "title": "weston_content_protection",
                    "text": "The global interface weston_content_protection is used for exposing th ontent protection capabilities to a client. It provides a way for client o request their wl_surface contents to not be displayed on an outpu elow their required level of content-protection.\nUsing this interface clients can request for a weston_protected_surfac hich is an extension to the wl_surface to provide content-protection, an et the censored-visibility on the non-secured-outputs."
                },
                {
                    "title": "weston_protected_surface",
                    "text": "An additional interface to a wl_surface object, which allows a client t equest the minimum level of content-protection, request to change th isibility of their contents, and receive notifications about changes i ontent-protection.\n\nA protected surface has a 'status' associated with it, that indicate hat type of protection it is currently providing, specified b ontent-type. Updates to this status are sent to the clien ia the 'status' event. Before the first status event is sent, the clien hould assume that the status is 'unprotected'.\n\nA client can request a content protection level to be the minimum for a utput to be considered secure, using the 'set_type' request.\nIt is responsibility of the client to monitor the actua ontent-protection level achieved via the 'status' event, and mak ecisions as to what content to show based on this.\n\nThe server should make its best effort to achieve the desire ontent-protection level on all of the outputs the client's contents ar eing displayed on. Any changes to the content protection status should b eported to the client, even if they are below the requeste ontent-protection level. If the client's contents are being displayed o ultiple outputs, the lowest content protection level achieved should b eported.\n\nA client can also request that its content only be displayed on output hat are considered secure. The 'enforce/relax' requests can achieve this.\nIn enforce mode, the content is censored for non-secure outputs.\nThe implementation of censored-visibility is compositor-defined.\nIn relax mode there are no such limitation. On an attempt to show th lient on unsecured output, compositor would keep on showing the conten nd send the 'status' event to the client. Client can take a call t owngrade the content.\n\nIf the wl_surface associated with the protected_surface is destroyed,\nthe protected_surface becomes inert."
                }
            ],
            "tags": {
                "source": "weston",
                "stability": "unstable"
            },
            "source": "weston-protocols",
            "supportIf": {},
            "supportSum": {},
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "weston-debug",
            "name": "Weston debug",
            "descFull": [
                {
                    "title": "weston_debug_v1",
                    "text": "This is a generic debugging interface for Weston internals, the globa bject advertized through wl_registry.\n\nWARNING: This interface by design allows a denial-of-service attack. I hould not be offered in production, or proper authorization mechanism ust be enforced.\n\nThe idea is for a client to provide a file descriptor that the serve ses for printing debug information. The server uses the fil escriptor in blocking writes mode, which exposes the denial-of-servic isk. The blocking mode is necessary to ensure all debug messages ca e easily printed in place. It also ensures message ordering if  lient subscribes to more than one debug stream.\n\nThe available debugging features depend on the server.\n\nA debug stream can be one-shot where the server prints the requeste nformation and then closes it, or continuous where server keeps o rinting until the client stops it. Or anything in between."
                },
                {
                    "title": "weston_debug_stream_v1",
                    "text": "Represents one subscribed debug stream, created wit eston_debug_v1.subscribe. When the object is created, it is associate ith a given file descriptor. The server will continue writing to th ile descriptor until the object is destroyed or the server sends a vent through the object."
                }
            ],
            "tags": {
                "source": "weston",
                "stability": "unstable"
            },
            "source": "weston-protocols",
            "supportIf": {},
            "supportSum": {},
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "weston-desktop-shell",
            "name": "Weston desktop shell",
            "descFull": [
                {
                    "title": "weston_desktop_shell",
                    "text": "Traditional user interfaces can rely on this interface to define th oundations of typical desktops. Currently it's possible to set u ackground, panels and locking surfaces."
                },
                {
                    "title": "weston_screensaver",
                    "text": "Only one client can bind this interface at a time."
                }
            ],
            "tags": {
                "source": "weston",
                "stability": "unstable"
            },
            "source": "weston-protocols",
            "supportIf": {
                "weston_desktop_shell": {
                    "weston": 1
                }
            },
            "supportSum": {
                "weston": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "weston-direct-display",
            "name": "Weston direct display",
            "descFull": [
                {
                    "title": "weston_direct_display_v1",
                    "text": "Weston extension to instruct the compositor to avoid any impor f the dmabuf created by 'linux-dmabuf' protocol other than the displa ontroller.\n\nCompositors are already going to use direct scan-out as much as possible bu here's no assurance that while doing so, they won't first import the dmabu n to the GPU. This extension assures the client that the compositor wil ever attempt to import in to the GPU and pass it directly to the displa ontroller.\n\nClients can make use of this extension to pass the dmabuf buffer to th isplay controller, potentially increasing the performance and lowering th andwidth usage.\n\nLastly, clients can make use of this extension in tandem with content-protectio ne thus avoiding any GPU interaction and providing a secure-content path.\nAlso, in some cases, the memory where dmabuf are allocated are in speciall rafted memory zone which would be seen as an illegal memory access when th PU will attempt to read it.\n\nWARNING: This interface by design might break screenshoting functionalit s compositing might be involved while doing that. Also, do note, that i ase the dmabufer provided can't be imported by KMS, the client connectio ill be terminated.\n\nWARNING: This extension requires 'linux-dmabuf' protocol and\n'zwp_linux_buffer_params_v1' be already created by 'zwp_linux_buffer_v1'."
                }
            ],
            "tags": {
                "source": "weston",
                "stability": "unstable"
            },
            "source": "weston-protocols",
            "supportIf": {},
            "supportSum": {},
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "weston-output-capture",
            "name": "Weston output capture",
            "descFull": [
                {
                    "title": "weston_capture_v1",
                    "text": "The global interface exposing Weston screenshooting functionalit ntended for single shots.\n\nThis is a privileged inteface."
                },
                {
                    "title": "weston_capture_source_v1",
                    "text": "An object representing image capturing functionality for a singl ource. When created, it sends the initial events if and only if th utput still exists and the specified pixel source is available o he output."
                }
            ],
            "tags": {
                "source": "weston",
                "stability": "unstable"
            },
            "source": "weston-protocols",
            "supportIf": {
                "weston_capture_v1": {
                    "weston": 1
                }
            },
            "supportSum": {
                "weston": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "weston-test",
            "name": "Weston test",
            "descFull": [
                {
                    "title": "weston_test",
                    "text": "Internal testing facilities for the weston compositor.\n\nIt can't be stressed enough that these should never ever be use utside of running weston's tests.  The weston-test.so module shoul ever be installed.\n\nThese requests may allow clients to do very bad things."
                },
                {
                    "title": "weston_test_runner",
                    "text": "This is a global singleton interface for Weston internal tests.\n\nThis interface allows a test client to trigger compositor-sid est procedures. This is useful for cases, where the actual test re in compositor plugins, but they also require the presence o  particular client.\n\nThis interface is implemented by the compositor plugins containin he testing code.\n\nA test client starts a test with the \"run\" request. It must not sen nother \"run\" request until receiving the \"finished\" event. If th ompositor-side test succeeds, the \"finished\" event is sent. If th ompositor-side test fails, the compositor should send the protoco rror \"test_failed\", but it may also exit with an error (e.g. SEGV).\n\nUnknown test name will raise \"unknown_test\" protocol error."
                }
            ],
            "tags": {
                "source": "weston",
                "stability": "unstable"
            },
            "source": "weston-protocols",
            "supportIf": {},
            "supportSum": {},
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "weston-touch-calibration",
            "name": "Weston touch calibration",
            "descFull": [
                {
                    "title": "weston_touch_calibration",
                    "text": "This is the global interface for calibrating a touchscreen inpu oordinate transformation. It is recommended to make this interfac rivileged.\n\nThis interface can be used by a client to show a calibration pattern an eceive uncalibrated touch coordinates, facilitating the computation o  calibration transformation that will align actual touch position n screen with their expected coordinates.\n\nImmediately after being bound by a client, the compositor sends th ouch_device events.\n\nThe client chooses a touch device from the touch_device events, creates  l_surface and then a weston_touch_calibrator for the wl_surface and th hosen touch device. The client waits for the compositor to send  onfigure event before it starts drawing the first calibration pattern.\nAfter receiving the configure event, the client will iterate drawing  attern, getting touch input via weston_touch_calibrator, and convertin ixel coordinates to expected touch coordinates wit eston_touch_calibrator.convert until it has enough correspondences t ompute the calibration transformation or the compositor cancels th alibration.\n\nOnce the client has successfully computed a new calibration, it can us eston_touch_calibration.save request to load the new calibration int he compositor. The compositor may take this new calibration into use an ay write it into persistent storage."
                },
                {
                    "title": "weston_touch_calibrator",
                    "text": "On creation, this object is tied to a specific touch device. Th ompositor sends a configure event which the client must obey with th ssociated wl_surface.\n\nOnce the client has committed content to the surface, the compositor ca rab the touch input device, prevent it from emitting normal touc vents, show the surface on the correct output, and relay input event rom the touch device via this protocol object.\n\nTouch events from other touch devices than the one tied to this objec ust generate wrong_touch events on at least touch-down and must no enerate normal or calibration touch events.\n\nAt any time, the compositor can choose to cancel the calibratio rocedure by sending the cancel_calibration event. This should also b sed if the touch device disappears or anything else prevents th alibration from continuing on the compositor side.\n\nIf the wl_surface is destroyed, the compositor must cancel th alibration.\n\nThe touch event coordinates and conversion results are delivered i alibration units. The calibration units cover the device coordinat ange exactly. Calibration units are in the closed interval [0.0, 1.0]\nmapped into 32-bit unsigned integers. An integer can be converted into  eal value by dividing by 2^32-1. A calibration matrix must be compute rom the [0.0, 1.0] real values, but the matrix elements do not need t all into that range."
                }
            ],
            "tags": {
                "source": "weston",
                "stability": "unstable"
            },
            "source": "weston-protocols",
            "supportIf": {},
            "supportSum": {},
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "treeland-capture-unstable-v1",
            "name": "Treeland capture",
            "desc": "protocol for capturing output contents or window contents",
            "descFull": [
                {
                    "title": "Treeland capture",
                    "text": "This protocol allows authorized application to capture output contents or windo ontents(useful for window streaming)."
                }
            ],
            "tags": {
                "source": "treeland",
                "stability": "unstable"
            },
            "source": "treeland-protocols",
            "supportIf": {
                "treeland_capture_manager_v1": {
                    "treeland": 1
                }
            },
            "supportSum": {
                "treeland": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "treeland-dde-shell-v1",
            "name": "Treeland DDE shell",
            "descFull": [
                {
                    "title": "treeland_dde_shell_manager_v1",
                    "text": "This interface allows DDE change some treeland function.\n\nWarning! The protocol described in this file is currently in the testin hase. Backward compatible changes may be added together with th orresponding interface version bump. Backward incompatible changes ca nly be done by creating a new major version of the extension."
                },
                {
                    "title": "treeland_window_overlap_checker",
                    "text": "A treeland_dde_shell_handle_v1 object represents an opened toplevel window. Eac pp may have multiple opened toplevels.\n\nWarning! The protocol described in this file is currently in the testin hase. Backward compatible changes may be added together with th orresponding interface version bump. Backward incompatible changes ca nly be done by creating a new major version of the extension."
                },
                {
                    "title": "treeland_dde_shell_surface_v1",
                    "text": "An interface that may be implemented by a wl_surface, fo mplementations that provide the shell user interface.\n\nIt provides requests to set surface role, set skip, set the positio et auto placement in output coordinates.\n\nOn the server side the object is automatically destroyed whe he related wl_surface is destroyed.  On client side,\ntreeland_dde_shell_surface_v1.destroy() must be called befor estroying the wl_surface object."
                },
                {
                    "title": "treeland_dde_active_v1",
                    "text": "An interface used to monitor special events."
                },
                {
                    "title": "treeland_multitaskview_v1",
                    "text": "An interface used to control multitaskview."
                },
                {
                    "title": "treeland_window_picker_v1",
                    "text": "An interface used to pick window and return credentials."
                },
                {
                    "title": "treeland_lockscreen_v1",
                    "text": "An interface used to operate lockscreen."
                }
            ],
            "tags": {
                "source": "treeland",
                "stability": "unstable"
            },
            "source": "treeland-protocols",
            "supportIf": {
                "treeland_dde_shell_manager_v1": {
                    "treeland": 1
                }
            },
            "supportSum": {
                "treeland": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "treeland-foreign-toplevel-manager-v1",
            "name": "Treeland foreign toplevel manager",
            "descFull": [
                {
                    "title": "treeland_foreign_toplevel_manager_v1",
                    "text": "This interface allows a client to get toplevel some info.\n\nWarning! The protocol described in this file is currently in the testin hase. Backward compatible changes may be added together with th orresponding interface version bump. Backward incompatible changes ca nly be done by creating a new major version of the extension."
                },
                {
                    "title": "treeland_foreign_toplevel_handle_v1",
                    "text": "A treeland_foreign_toplevel_handle_v1 object represents an opened toplevel window. Eac pp may have multiple opened toplevels.\n\nWarning! The protocol described in this file is currently in the testin hase. Backward compatible changes may be added together with th orresponding interface version bump. Backward incompatible changes ca nly be done by creating a new major version of the extension."
                },
                {
                    "title": "treeland_dock_preview_context_v1",
                    "text": "This interface allows dock set windows preview.\n\nWarning! The protocol described in this file is currently in the testin hase. Backward compatible changes may be added together with th orresponding interface version bump. Backward incompatible changes ca nly be done by creating a new major version of the extension."
                }
            ],
            "tags": {
                "source": "treeland",
                "stability": "unstable"
            },
            "source": "treeland-protocols",
            "supportIf": {
                "treeland_foreign_toplevel_manager_v1": {
                    "treeland": 1
                }
            },
            "supportSum": {
                "treeland": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "treeland-output-manager-v1",
            "name": "Treeland output manager",
            "descFull": [
                {
                    "title": "treeland_output_manager_v1",
                    "text": "Protocol for telling which is the primary display among the selection of enable utputs."
                }
            ],
            "tags": {
                "source": "treeland",
                "stability": "unstable"
            },
            "source": "treeland-protocols",
            "supportIf": {
                "treeland_output_manager_v1": {
                    "treeland": 1
                }
            },
            "supportSum": {
                "treeland": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "treeland-personalization-manager-v1",
            "name": "Treeland personalization manager",
            "descFull": [
                {
                    "title": "treeland_personalization_manager_v1",
                    "text": "This interface allows a client to customized display effects.\n\nWarning! The protocol described in this file is currently in the testin hase. Backward compatible changes may be added together with th orresponding interface version bump. Backward incompatible changes ca nly be done by creating a new major version of the extension."
                },
                {
                    "title": "treeland_personalization_wallpaper_context_v1",
                    "text": "This interface allows a client personalization wallpaper.\n\nWarning! The protocol described in this file is currently in the testin hase. Backward compatible changes may be added together with th orresponding interface version bump. Backward incompatible changes ca nly be done by creating a new major version of the extension."
                },
                {
                    "title": "treeland_personalization_cursor_context_v1",
                    "text": "This interface allows a client personalization cursor.\n\nWarning! The protocol described in this file is currently in the testin hase. Backward compatible changes may be added together with th orresponding interface version bump. Backward incompatible changes ca nly be done by creating a new major version of the extension."
                },
                {
                    "title": "treeland_personalization_window_context_v1",
                    "text": "This interface allows a client personalization window.\n\nWarning! The protocol described in this file is currently in the testin hase. Backward compatible changes may be added together with th orresponding interface version bump. Backward incompatible changes ca nly be done by creating a new major version of the extension."
                },
                {
                    "title": "treeland_personalization_font_context_v1",
                    "text": "This interface allows set treeland window global font settings.\n\nWarning! The protocol described in this file is currently in the testin hase. Backward compatible changes may be added together with th orresponding interface version bump. Backward incompatible changes ca nly be done by creating a new major version of the extension."
                },
                {
                    "title": "treeland_personalization_appearance_context_v1",
                    "text": "This interface allows set treeland window global appearance settings.\n\nWarning! The protocol described in this file is currently in the testin hase. Backward compatible changes may be added together with th orresponding interface version bump. Backward incompatible changes ca nly be done by creating a new major version of the extension."
                }
            ],
            "tags": {
                "source": "treeland",
                "stability": "unstable"
            },
            "source": "treeland-protocols",
            "supportIf": {
                "treeland_personalization_manager_v1": {
                    "treeland": 1
                }
            },
            "supportSum": {
                "treeland": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "treeland-shortcut-manager-v1",
            "name": "Treeland shortcut manager",
            "descFull": [
                {
                    "title": "treeland_shortcut_manager_v1",
                    "text": "This interface allows a client to get some shell's info.\n\nWarning! The protocol described in this file is currently in the testin hase. Backward compatible changes may be added together with th orresponding interface version bump. Backward incompatible changes ca nly be done by creating a new major version of the extension."
                },
                {
                    "title": "treeland_shortcut_context_v1",
                    "text": "This interface allows a client to listen a shortcut action.\n\nWarning! The protocol described in this file is currently in the testin hase. Backward compatible changes may be added together with th orresponding interface version bump. Backward incompatible changes ca nly be done by creating a new major version of the extension."
                }
            ],
            "tags": {
                "source": "treeland",
                "stability": "unstable"
            },
            "source": "treeland-protocols",
            "supportIf": {
                "treeland_shortcut_manager_v1": {
                    "treeland": 1
                }
            },
            "supportSum": {
                "treeland": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "treeland-virtual-output-manager-v1",
            "name": "Treeland virtual output manager",
            "descFull": [
                {
                    "title": "treeland_virtual_output_manager_v1",
                    "text": "This interface is a manager that allows the creation of copied output."
                },
                {
                    "title": "treeland_virtual_output_v1",
                    "text": "A treeland_virtual_output_v1 represents a set virtual screen output object."
                }
            ],
            "tags": {
                "source": "treeland",
                "stability": "unstable"
            },
            "source": "treeland-protocols",
            "supportIf": {
                "treeland_virtual_output_manager_v1": {
                    "treeland": 1
                }
            },
            "supportSum": {
                "treeland": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "treeland-wallpaper-color-v1",
            "name": "Treeland wallpaper color",
            "descFull": [],
            "tags": {
                "source": "treeland",
                "stability": "unstable"
            },
            "source": "treeland-protocols",
            "supportIf": {
                "treeland_wallpaper_color_manager_v1": {
                    "treeland": 1
                }
            },
            "supportSum": {
                "treeland": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "treeland-window-management-v1",
            "name": "Treeland window managment",
            "descFull": [
                {
                    "title": "treeland_window_management_v1",
                    "text": "This interface manages application windows.\nIt provides requests to show and hide the desktop and emit n event every time a window is created so that the client ca se it to manage the window.\n\nOnly one client can bind this interface at a time."
                }
            ],
            "tags": {
                "source": "treeland",
                "stability": "unstable"
            },
            "source": "treeland-protocols",
            "supportIf": {
                "treeland_window_management_v1": {
                    "treeland": 1
                }
            },
            "supportSum": {
                "treeland": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "wayland-drm",
            "name": "Mesa Wayland DRM",
            "descFull": [],
            "tags": {
                "source": "external",
                "stability": "unstable"
            },
            "source": "external",
            "supportIf": {
                "wl_drm": {
                    "mutter": 1,
                    "kwin": 1,
                    "cosmic": 1,
                    "hyprland": 1,
                    "niri": 1,
                    "weston": 1,
                    "labwc": 1,
                    "gamescope": 1,
                    "jay": 1,
                    "mir": 1,
                    "louvre": 1
                }
            },
            "supportSum": {
                "mutter": "full",
                "kwin": "full",
                "cosmic": "full",
                "hyprland": "full",
                "niri": "full",
                "weston": "full",
                "labwc": "full",
                "gamescope": "full",
                "jay": "full",
                "mir": "full",
                "louvre": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "agl-shell",
            "name": "AGL shell",
            "descFull": [
                {
                    "title": "agl_shell",
                    "text": "Starting with version 2 of the protocol, the client is required to wai or the 'bound_ok' or 'bound_fail' events in order to proceed further.\n\nIn case the client gets a 'bound_fail' event then it should consider tha here's another client already bound to the agl_shell protocol.\nA client that receives a 'bound_ok' event should consider that there' o other client already bound to the interface and can proceed further.\n\nIf the client uses an older version of the protocol it will receiv utomatically an error and the compositor will terminate the connection,\nif there's another client already bound the interface.\n\nIf the client receives the 'bound_fail' event and attempts to use th nterface further it will receive an error and the compositor wil erminate the connection. After the 'bound_fail' event was received th lient should call the destructor, which has been added with version  f the protocol. The client is free to try at a later point in time t ee if it will receive the 'bound_ok' event, but there's no explicit wa f finding out when that event will be delivered.\nIt is assumed that it can infer that information through othe eans/other channels."
                },
                {
                    "title": "agl_shell_ext",
                    "text": "This interface allows another client bind to the agl_shell interface,\nwhile there's another shell client already present.\n\nThe client should first bind to this interface and then inform th ompositor with the 'doas_shell_client' request and it wants to bind t he agl_shell interface. The client is still expected, if using a ne ersion of the agl_shell interface, to wait for the 'bound_ok' and\n'bound_fail' events before issueing any other requests/events.\n\nNote that this interface has its limitations, and the compositor woul till refuse the act for 'set_panel' or 'set_background' request f the agl_shell interface if there's already a client that used them.\n\nAny other requests or events should be delievered and handled as it woul  client bound to the agl_shell interface."
                }
            ],
            "tags": {
                "source": "external",
                "stability": "unstable"
            },
            "source": "external",
            "supportIf": {},
            "supportSum": {},
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "agl-shell-desktop",
            "name": "AGL shell desktop",
            "descFull": [
                {
                    "title": "agl_shell_desktop",
                    "text": "This extension can be used by regular application to instruct to composito o activate or switch to other running (regular) applications. The clien s responsible for filtering their own app_id when receiving application id.\n\nThe compositor will allow clients to bind to this interface only if th olicy engine allows it."
                }
            ],
            "tags": {
                "source": "external",
                "stability": "unstable"
            },
            "source": "external",
            "supportIf": {},
            "supportSum": {},
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "agl-screenshooter",
            "name": "AGL screenshooter",
            "descFull": [
                {
                    "title": "agl_screenshooter",
                    "text": "agl compositor extension that performs a screenshot of the output, whic s represented by a 'wl_output' object.\n\nA client would call 'take_shot' request and wait until the composito inishes to write the data to a wayland buffer, moment in which signal ack the client with the help of the 'done' event. Clients should wai ntil the 'done' event is received, if they want to take anothe creenshot, or take another screnshot of a different output.\n\nThe client must provide a wl_shm-based wl_buffer of the correct size whe aking a shot. The compositor will write the shot into the wl_buffer and the end the 'done' event that signals completion of writing the data.\n\nOnce the compositor has finished to transfer the data back into the supplie ayland buffer, the client should be able to transfer it to a popula ile format on the disk."
                }
            ],
            "tags": {
                "source": "external",
                "stability": "unstable"
            },
            "source": "external",
            "supportIf": {},
            "supportSum": {},
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "aura-output-management",
            "name": "Chromium aura output management",
            "descFull": [
                {
                    "title": "zaura_output_manager_v2",
                    "text": "A global responsible for propagating atomic output configuration change o clients. An output configuration is a union of added / removed output nd updated output metrics.\n\nAdded outputs arrive at the client as wl_registry.global events, remove utputs as wl_registry.global_remove events and updated output metrics a  sequence of events defined on the zaura_output_manager_v2 interface.\nThis is followed by the manager's done event which signals the end of th ransaction.\n\nThe change should be processed by clients in a way that transitions fro ne output configuration state to another without exposing th ntermediate output state to the rest of the application.\n\nParticipating servers should emit the zaura_output_manager_v2 globa efore any wl_output globals in the sequence of wl_registry.global events.\n\nParticipating clients should bind the zaura_output_manager_v2 before an l_output globals. This ordering is required to ensure clients receive al ecessary output configuration information before receiving any furthe erver events that may reference bound wl_outputs.\n\nClients can expect that all events comprising a configuration change ar ent synchronously, one after the other, before any other server event hat leverage the output as an event param."
                }
            ],
            "tags": {
                "source": "external",
                "stability": "unstable"
            },
            "source": "external",
            "supportIf": {},
            "supportSum": {},
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "aura-shell",
            "name": "Chromium aura shell",
            "descFull": [
                {
                    "title": "zaura_shell",
                    "text": "The global interface exposing aura shell capabilities is used t nstantiate an interface extension for a wl_surface object.\nThis extended interface will then allow the client to use aura shel pecific functionality."
                },
                {
                    "title": "zaura_surface",
                    "text": "An additional interface to a wl_surface object, which allows th lient to access aura shell specific functionality for surface."
                },
                {
                    "title": "zaura_output",
                    "text": "An additional interface to a wl_output object, which allows th lient to access aura shell specific functionality for output."
                },
                {
                    "title": "zaura_toplevel",
                    "text": "An interface to the toplevel shell, which allows th lient to access shell specific functionality."
                },
                {
                    "title": "zaura_popup",
                    "text": "An interface to the popup shell, which allows th lient to access shell specific functionality."
                },
                {
                    "title": "zaura_output_manager",
                    "text": "[Deprecated] Deprecated since M122. See the zaura_output_manager_v nterface.\n\nA global responsible for ensuring clients have a complete view of a give utput's state immediately following the bind of wl_output, an ubsequently as needed.\n\nClients can expect that all the manager's events for a given wl_outpu rrive before the associated wl_output.done event. Clients must bind t he manager global before any output globals."
                }
            ],
            "tags": {
                "source": "external",
                "stability": "unstable"
            },
            "source": "external",
            "supportIf": {},
            "supportSum": {},
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "chrome-color-management",
            "name": "Chromium color management",
            "desc": "color management protocol",
            "descFull": [
                {
                    "title": "Chromium color management",
                    "text": "This protocol specifies a way for a client to set the color space an DR metadata of a surface and to get information about the color space nd HDR capabilities of outputs.\n\nThis protocol is based on a proposed upstream protocol, which we will migrat o once it is approved. It may diverge from the proposed upstream protoco ver the course of our development."
                },
                {
                    "title": "zcr_color_manager_v1",
                    "text": "A global interface used for getting color management surface and colo anagement output objects as well as creating color space objects fro CC profiles, parameters, or enumerated names."
                },
                {
                    "title": "zcr_color_management_output_v1",
                    "text": "A zcr_color_management_output_v1 describes the color properties of a utput.\n\nWhen zcr_color_management_output_v1 object is created, it will sen ts initial events followed by a wl_output.done event. When creatin l_output and its extension objects, use a final wl_display.sync t uarantee that all output events have been received across al xtensions.\n\nIf the wl_output associated with the zcr_color_management_output_v1 i estroyed, the zcr_color_management_output_v1 object becomes inert."
                },
                {
                    "title": "zcr_color_management_surface_v1",
                    "text": "A zcr_color_management_surface_v1 allows the client to set the colo pace and HDR properties of a surface.\n\nIf the wl_surface associated with the zcr_color_management_surface_v1 i estroyed, the zcr_color_management_surface_v1 object becomes inert."
                },
                {
                    "title": "zcr_color_space_creator_v1",
                    "text": "A zcr_color_space_creator_v1 object returns a created color spac r the error which occured during creation.\n\nOnce a zcr_color_space_creator_v1 object has delivered a 'created'\nor 'error' event it is automatically destroyed."
                },
                {
                    "title": "zcr_color_space_v1",
                    "text": "Refers to a color space which can be attached to a surface\n(zcr_color_management_surface_v1.set_color_space). It may provid nformation like the ICC profile and the well-known names to allo lients to know the color space and do color transformations of thei wn.\n\nOnce created and regardless of how it was created, a zcr_color_space_v bject always refers to one fixed color space.\n\nThe client can create a zcr_color_space_v1 object wit cr_color_manager_v1 requests or from an output by callin cr_color_management_output_v1.get_color_space.\n\nOther extensions may define more zcr_color_space_v1 factory interfaces.\nThose interfaces must explicitly specify the interface version for th bject created, otherwise versioning zcr_color_space_v1 correctl ecomes impossible. Using a 'new_id' argument without 'interface'\nattribute defined in XML forces code generators to add two explici rguments: interface and version. Version is the explicit versio umber needed, and interface should be required to be\n\"zcr_color_space_v1\". The compositor supported zcr_color_space_v ersions are defined by the advertised zcr_color_manager_v1 i l_registry."
                }
            ],
            "tags": {
                "source": "external",
                "stability": "unstable"
            },
            "source": "external",
            "supportIf": {},
            "supportSum": {},
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "overlay-prioritizer",
            "name": "Chromium overlay prioritizer",
            "descFull": [
                {
                    "title": "overlay_prioritizer",
                    "text": "The global interface exposing overlay delegated prioritizatio int capabilities is used to instantiate an interface extension for  l_surface object. This extended interface will then allo elegated overlay prioritization of the surface."
                },
                {
                    "title": "overlay_prioritized_surface",
                    "text": "An additional interface to a wl_surface object, which allows th lient to specify hints for the overlay prioritization of the surface."
                }
            ],
            "tags": {
                "source": "external",
                "stability": "unstable"
            },
            "source": "external",
            "supportIf": {},
            "supportSum": {},
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "surface-augmenter",
            "name": "Chromium surface augmenter",
            "descFull": [
                {
                    "title": "surface_augmenter",
                    "text": "The global interface exposing surface delegated compositio apabilities is used to instantiate an interface extension for  l_surface object. This extended interface will then allo elegated compostion of the surface contents, effectivel isconnecting the direct relationship between the buffer and th urface content (adding support for solid quads and rounded corne or instance)."
                },
                {
                    "title": "augmented_surface",
                    "text": "An additional interface to a wl_surface object, which allows th lient to specify the delegated composition of the surfac ontents.\n\n\nThis makes the surface an object only used to composite its paren urface. This means the surface will be clipped to the parent bounds, wil ot receive input events or display enter/leave events, etc.\n\nUse wl_subsurface role objects to express which parent surface this wil erform delegate composition for.\n\nThe commits to this surface is assumed to behave synchronized with it arent commits, as a synchronized wl_subsurface would.\n\nThe compositor does not perform fine-grained damage extension calculatio hat is introduced by an augmented_surface moving, resizing, changin tacking, or disappearing. A client performing such operations shoul ccount for it and damage the parent non-augmented wl_surface accordingly.\n\nVarious changes like adding or removing an augmented sub-surface, changin ts position or stacking order, will not introduce extra damage on th ompositor side. The parent wl_surface should account for the extra damag ntroduced.\n\nThis surface, using a wl_subsurface role of its parent, cannot be stacke elative to non-augmented sub-surfaces of the parent, but can be stacke elative to other augmented children. Nor can this surface hav on-augmented sub-surface children.\n\nA mixed tree structure of using augmented_surfaces to delegate composit l_surfaces would look like this:\n\nwl_surface@1:{ augmented_surface@1,2,3 }\n/           \\_____\n/                   \\\nwl_surface@2:               wl_surface@3:\n{ augmented_surface@4,5 }   { augmented_surface@6 }\n\nEvery wl_surface has a list of augmented_surfaces. Assuming th l_surface stacking order, from bottom to top, is:\nwl_surface@1, wl_surface@2, wl_surface@3\n\nThen the final composition order, from bottom to top, is:\nwl_surface@1, augmented_surface@1,2,3, wl_surface@2, augmented_surface@4,5,\nwl_surface@3, augmented_surface@6"
                },
                {
                    "title": "augmented_sub_surface",
                    "text": "An additional interface to a wl_subsurface object, which allows th lient to specify the delegated composition of the surfac ontents."
                }
            ],
            "tags": {
                "source": "external",
                "stability": "unstable"
            },
            "source": "external",
            "supportIf": {},
            "supportSum": {},
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "virtual-keyboard-unstable-v1",
            "name": "Virtual keyboard",
            "descFull": [
                {
                    "title": "zwp_virtual_keyboard_v1",
                    "text": "The virtual keyboard provides an application with requests which emulat he behaviour of a physical keyboard.\n\nThis interface can be used by clients on its own to provide raw inpu vents, or it can accompany the input method protocol."
                },
                {
                    "title": "zwp_virtual_keyboard_manager_v1",
                    "text": "A virtual keyboard manager allows an application to provide keyboar nput events as if they came from a physical keyboard."
                }
            ],
            "tags": {
                "source": "external",
                "stability": "unstable"
            },
            "source": "external",
            "supportIf": {
                "zwp_virtual_keyboard_manager_v1": {
                    "sway": 1,
                    "cosmic": 1,
                    "hyprland": 1,
                    "niri": 1,
                    "labwc": 1,
                    "cage": 1,
                    "wayfire": 1,
                    "jay": 1,
                    "mir": 1,
                    "treeland": 1
                }
            },
            "supportSum": {
                "sway": "full",
                "cosmic": "full",
                "hyprland": "full",
                "niri": "full",
                "labwc": "full",
                "cage": "full",
                "wayfire": "full",
                "jay": "full",
                "mir": "full",
                "treeland": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "tizen-extension",
            "name": "Tizen extension",
            "descFull": [
                {
                    "title": "tizen_surface",
                    "text": "The tizen_surface provides tizen-specific functionalities for the give urface."
                },
                {
                    "title": "tizen_resource",
                    "text": "This tizen_resource provides a global resource id. It is a unique i hich is provided by the display server."
                },
                {
                    "title": "tizen_policy",
                    "text": "The tizen_policy provides tizen-specific requests and events for windo anagement at Tizen Platform.\n\n[TODO] Explain the window layer at the display server. Need to explain th indow layer to understand the requests and the events at tizen_polic nterface."
                },
                {
                    "title": "tizen_visibility",
                    "text": "A client wants to know the visiblity information of the surface."
                },
                {
                    "title": "tizen_position",
                    "text": "A client can set the position information of the surface."
                },
                {
                    "title": "tizen_keyrouter",
                    "text": "In tradition, all the keys in a keyboard and a device on whic ome keys are attached will be sent to focus surface by default.\nCurrently it's possible to set up each focus for each key in a keyboard and a device.\nTherefore, by setting a key grab for a surface, the owner of th urface will get the key event when it has the key grab for the key."
                },
                {
                    "title": "tizen_screenshooter",
                    "text": "Clients can get a screenmirror object from this interface."
                },
                {
                    "title": "tizen_screenmirror",
                    "text": "A client can use this interface to get stream images of screen. Before starting,\nqueue all buffers. Then, start a screenmirror. After starting, a dequeued even ill occur when drawing a captured image on a buffer is finished. You migh eed to queue the dequeued buffer again to get a new image from display server."
                },
                {
                    "title": "tizen_video",
                    "text": "Clients can get the video information that the compositor can handle from this interface."
                },
                {
                    "title": "tizen_viewport",
                    "text": "This is the alternative and convenient solution of wl_viewport to presen  surface on screen.\n\nThe below five functions can be replaced with this interface. The belo unctions will be ignored after applying this interface to a surface.\n- wl_surface.set_buffer_transform\n- wl_surface.set_buffer_scale\n- wl_subsurface.set_position\n- wl_viewport.set_source\n- wl_viewport.set_destination\n\nwl_viewport.set_source is very complicated especially when the buffer o l_surface is transformed by wl_surface.set_buffer_transform. And when th arent is resized, if we want to change the geometry of a subsurface also,\nwl_subsurface.set_position and wl_viewport.set_destination should be calle verytime the parent is resized in client side. This makes difficult t ynchronize a parent surface and a subsurface on screen.\n\ntizen_viewport allows clients to set the relative geometry to a subsurfac n a parent surface. Whenever a parent surface is resized, the geometry o  subsurface will be calculated, moved and resized automatically by  ompositor. The tizen_viewport is specified in the coordinates of  ubsurface's parent.\n\nIf tizen_viewport is applied to a shell surface(toplevel), the all value relate ith x, y pos of tizen_viewport and tizen_destination_mode interface will be ignored.\n\nThe below 3 functions don't consider the transform of a parent's surface.\n- tizen_viewport.set_source\n- tizen_viewport.set_destination\n- tizen_viewport.set_destination_ratio\n\nFurthermore, tizen_destination_mode.follow_parent_transform is called,\ntizen_viewport will consider the transform of a parent surface when applyin he destination mode to a subsurface. If tizen_destination_mode.follow_parent_transfor s applied to a shell surface, it will be ignored.\n\nThe destination will be cropped by a parent surface.\n\nThe change will be applied when wl_surface.commit is called."
                },
                {
                    "title": "tizen_destination_mode",
                    "text": "The destination rectangle will be automatically changed when a parent i esized. When tizen_destination_mode.set is called, the value o izen_viewport.set_destination and tizen_viewport.set_destination_rati ill be ignored.\n\nThe destination of a surface is decided by the mode, ratio, scale, offse nd align values. The ratio, scale, offset and align will be applie equentially.\n\nThe change will be applied when wl_surface.commit is called."
                },
                {
                    "title": "tizen_embedded_compositor",
                    "text": "The global obejct. Wayland has 3 type of compositor, embedded compositor is one of them.\nBut tizen application is sendboxing by smack, then a application not allow commutication to other application by socket.\nSo system or session compositor create socket and send to embedded compostior."
                },
                {
                    "title": "tizen_input_device_manager",
                    "text": "Tizen input device manager is a global interface. This object has device add/remove event o provide tizen input device object to a client. This allows for a client to get the con\n\nBe sure to bind this interface after binding wl_seat interface.\nTizen input device manager interface will only provide device add/remove event for device hich belongs to the wl_seat object(s) bound by the client. Therefore, the compositor needs t reate/send the device add/remove event only for the current client's seat(s)."
                },
                {
                    "title": "tizen_input_device",
                    "text": "The tizen_input_device interface represents one or more input devices associated with a physical/logica nput device. This interface provides device specific information/events to allows for client to identif he source device of an event or to get the additional axes/attributes of a device.\nNote that a tizen_input_device object can be used for a physical input device and can also be used for  roup of input devices. e.g. a group of mouse devices"
                },
                {
                    "title": "tizen_clipboard",
                    "text": "This interface provides some requests and events about clipboard for other clients."
                }
            ],
            "tags": {
                "source": "external",
                "stability": "unstable"
            },
            "source": "external",
            "supportIf": {},
            "supportSum": {},
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "nvidia-eglstream",
            "name": "NVIDIA EGLStream",
            "descFull": [],
            "tags": {
                "source": "external",
                "stability": "unstable"
            },
            "source": "external",
            "supportIf": {
                "wl_eglstream_display": {
                    "louvre": 1
                }
            },
            "supportSum": {
                "louvre": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "nvidia-eglstream-controller",
            "name": "NVIDIA EGLStream controller",
            "descFull": [],
            "tags": {
                "source": "external",
                "stability": "unstable"
            },
            "source": "external",
            "supportIf": {},
            "supportSum": {},
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "gtk-shell",
            "name": "GTK Shell",
            "descFull": [
                {
                    "title": "gtk_shell1",
                    "text": "gtk_shell is a protocol extension providing additional features fo lients implementing it."
                }
            ],
            "tags": {
                "source": "external",
                "stability": "unstable"
            },
            "source": "external",
            "supportIf": {
                "gtk_shell1": {
                    "mutter": 1,
                    "wayfire": 1
                }
            },
            "supportSum": {
                "mutter": "full",
                "wayfire": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        },
        {
            "id": "mir-shell-unstable-v1",
            "name": "Mir Shell",
            "descFull": [
                {
                    "title": "mir_shell_v1",
                    "text": "Clients can use this interface to assign an archetype to wl_surfaces.\n\nAn archetype is like a `wl_surface` role: a surface may have at most on rchetype, but unlike a `wl_surface` role a client may assign a new archetyp o a surface which already has one. This will remove the old archetype an pply the new one atomically.\n\nThe archetype of a `wl_surface` influences the window-management policie pplied to it.\n\nAll archetype state is double-buffered; changing a surface archetype o pdates to any archetype state are not applied until the `wl_surface` is\n`commit`ted.\n\nTypically, archetype state will be used to augments `xdg_toplevel` state. If  lient intends to use an archetype, it SHOULD assign the surface an initia rchetype during the initial commit without a buffer attached (see `xdg_surface`).\n\nAny events sent to an archetype object are latched to and extend the\n`xdg_surface.configure` event. Any such events should be treated as a part o n atomic set of configuration changes (including any `xdg_toplevel` events)\nwith the `xdg_surface.configure` event committing the accumulated state an equiring a `xdg_surface.ack_configure` call, as normal.\n\nChanging archetype follows a similar sequence to the initial `xdg_surface`\ncommit. First, a new archetype must be committed. This must be the only stat ommitted in the `wl_surface.commit` request. The compositor will respond wit ny changes to the surface state prompted by the change of archetype followe y an `xdg_surface.configure` event. The client must ack the configure event\n(as normal) and the subsequent `wl_surface.commit` will cause the ne rchetype to be fully applied.\n\nThere are some `wl_surface` roles that conflict with the archetypes describe ere. Attempting to set both an archetypes and such roles on a surface is  rotocol error. In particular, `wl_subsurface`, `wl_cursor` or `xdg_popup` ma ot be combined with an archetype."
                },
                {
                    "title": "mir_regular_surface_v1",
                    "text": "An interface that may be implemented by a wl_surface, for surfaces tha re designed to be rendered in a desktop-like environment."
                },
                {
                    "title": "mir_floating_regular_surface_v1",
                    "text": "An interface that may be implemented by a wl_surface, for surfaces tha re designed to be rendered in a desktop-like environment."
                },
                {
                    "title": "mir_dialog_surface_v1",
                    "text": "An interface that may be implemented by a wl_surface, for surfaces tha re designed to be rendered in a desktop-like environment."
                },
                {
                    "title": "mir_satellite_surface_v1",
                    "text": "An interface that may be implemented by a wl_surface, for surfaces tha re designed to be rendered in a desktop-like environment."
                },
                {
                    "title": "mir_positioner_v1",
                    "text": "The mir_positioner provides a collection of rules for the placement of  hild surface relative to a parent surface. Rules can be defined to ensur he child surface remains within the visible area's borders, and t pecify how the child surface changes its position, such as sliding alon n axis, or flipping around a rectangle. These positioner-created rules ar onstrained by the requirement that a child surface must intersect with o e at least partially adjacent to its parent surface.\n\nSee the various requests for details about possible rules.\n\nAt the time of the request, the compositor makes a copy of the rule pecified by the mir_positioner. Thus, after the request is complete th ir_positioner object can be destroyed or reused; further changes to th bject will have no effect on previous usages.\n\nFor an mir_positioner object to be considered complete, it must have  on-zero size set by set_size, and a non-zero anchor rectangle set b et_anchor_rect. Passing an incomplete mir_positioner object whe ositioning a surface raises an invalid_positioner error."
                }
            ],
            "tags": {
                "source": "external",
                "stability": "unstable"
            },
            "source": "external",
            "supportIf": {
                "mir_shell_v1": {
                    "mir": 1
                }
            },
            "supportSum": {
                "mir": "full"
            },
            "defaultExpand": false,
            "deprecations": null
        }
    ]
}